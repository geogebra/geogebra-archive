
LocalSymbols(lastcoef,OrdBuild, AddFoundSolutionSingle , AddFoundSolution, Fct, MkfactD,p)
[

LastCoef(_vector,_p) <--
[
  Local(n);
  n:=Length(vector);
  Add(vector*p^(0 .. (n-1)));
];



OrdBuild(vector,q):=
[
  Local(i,result,n);
  Set(i,2);
  Set(result, 0);
  Set(n, Length(vector));
  While (i<=n)
  [
    Set(result,result+(i-1)*vector[i]*p^(i-2));
    Set(i, i+2);
  ];
  q*result;
];


Function(AddFoundSolutionSingle,{p})
[
  Local(calc);


    Set(calc, Eval(lastcoef));
    If (IsEqual(calc, 0),
    [
      Local(newlist,count,root);
      count:=0;
      root := p;
      Local(rem);

      rem:={-root,1};
      {testpoly,rem}:=MkfactD(testpoly,rem);

      rem:={-root,1};
      {newlist,rem}:=MkfactD(poly,rem);
      While (rem = {})
      [
        count++;
        Set(poly,newlist);
        rem:={-root,1};
        {newlist,rem}:=MkfactD(poly,rem);
      ];

      Local(lgcd,lc);
      Set(lgcd,Gcd({andiv,an,root}));
      Set(lc,Quotient(an,lgcd));
      Set(result,{var+ (-(Quotient(root,lgcd)/lc)),count}:result);
      Set(andiv,Quotient(andiv,lgcd^count));
      Set(anmul,anmul*lc^count);




      Local(p,q);
      Set(lastcoef, LastCoef(testpoly,p));
      Set(ord, OrdBuild(testpoly,q));
    ]);

];
UnFence(AddFoundSolutionSingle,1);

Function(AddFoundSolution,{p})
[
  AddFoundSolutionSingle(p);
  AddFoundSolutionSingle(-2*q+p);
];
UnFence(AddFoundSolution,1);

Function(Fct,{poly,var})
[
  Local(maxNrRoots,result,ord,p,q,accu,calc,twoq,mask);

  Local(gcd);
  [
    Set(gcd,Gcd(poly));
    If(poly[Length(poly)] < 0,Set(gcd, gcd * -1));
    Set(poly,poly/gcd);
  ];

  Local(unrat);
  Set(unrat,Lcm(MapSingle("Denominator",poly)));
  Set(poly,unrat*poly);

  Local(origdegree);
  Set(origdegree,Length(poly)-1);

  Local(an,andiv,anmul);
  Set(an,poly[Length(poly)]);
  Set(poly,poly* (an^((origdegree-1) .. -1)));
  Set(andiv,an^(origdegree-1));
  Set(anmul,1);

  Local(leadingcoef,lowestcoef);
  Set(leadingcoef,poly[Length(poly)]);
  [
    Local(i);
    Set(i,1);
    Set(lowestcoef,Abs(poly[i]));
    While (lowestcoef = 0 And i<=Length(poly))
    [
      Set(i,i+1);
      Set(lowestcoef,Abs(poly[i]));
    ];
  ];
  
  
  
  Local(testpoly);

  Local(deriv);
  
  deriv:=Rest(poly);
  [
    Local(i);
    For (i:=1,i<=Length(deriv),i++)
    [
      deriv[i] := deriv[i]*i;
    ];


  ];
  [
    Local(q,r,next);
    q:=poly;
    r:=deriv;
    While(r != {})
    [

      next := MkfactD(q,r)[2];
      q:=r;
      r:=next;
    ];
    

    
    q:=q/q[Length(q)];
    testpoly:=MkfactD(poly,q)[1];

  ];



  Set(maxNrRoots,Length(testpoly)-1);
  Set(result, {});

  Set(lastcoef, LastCoef(testpoly,p));
  Set(ord, OrdBuild(testpoly,q));

  Set(accu,{});
  Set(q,1);
  Set(twoq,MultiplyN(q,2));
  Set(mask,AddN(twoq,MathNegate(1)));
  if (IsEven(testpoly[1]))
  [
    Set(accu,0:accu);
    AddFoundSolutionSingle(0);
  ];
  Set(p,1);
  Set(calc, Eval(lastcoef));
  If (IsEven(calc),
  [
    Set(accu,1:accu);
    AddFoundSolution(1);
  ]);
  Set(q,twoq);
  Set(twoq,MultiplyN(q,2));
  Set(mask,AddN(twoq,MathNegate(1)));
  While(Length(result)<maxNrRoots And Length(accu)>0 And q<=Abs(testpoly[1]))
  [
    Local(newaccu);
    Set(newaccu,{});
    ForEach(p,accu)
    [
      Set(calc,Eval(lastcoef));
      If (IsLessThan(calc,0),
        Set(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))
         );
      Set(calc, BitAnd(calc, mask));
      If ( IsEqual(calc, 0),
      [
        Set(newaccu, p:newaccu);
        AddFoundSolutionSingle(-2*q+p);
      ]);
      Set(calc, AddN(calc, Eval(ord)));
      If (IsLessThan(calc,0),
        Set(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))
         );
      Set(calc, BitAnd(calc, mask));
      If ( IsEqual(calc, 0),
      [
        Set(newaccu, AddN(p,q):newaccu);
        AddFoundSolution(AddN(p,q));
      ]);
    ];
    Set(accu, newaccu);
    Set(q,twoq);
    Set(twoq,MultiplyN(q,2));
    Set(mask,AddN(twoq,MathNegate(1)));




  ];

  
  
  Set(poly,poly*an^(0 .. (Length(poly)-1)));
  Set(poly,gcd*anmul*poly);
  
  If(Not IsZero(unrat * andiv ),Set(poly,poly/(unrat * andiv )));
  If(poly != {1},
  [
    result:={(Add(poly*var^(0 .. (Length(poly)-1)))),1}:result;
  ]);
  result;
];



BinaryFactors(expr):=
[
  Local(result,uni,coefs);
  uni:=MakeUni(expr,VarList(expr)[1]);
  uni:=FunctionToList(uni);
  coefs:=uni[4];
  coefs:=Concat(ZeroVector(uni[3]),coefs);
  result:=Fct(coefs,uni[2]);



  result;
];



MkfactD(numer,denom):=
[
  Local(q,r,i,j,ln,ld,nq);
  DropEndZeroes(numer);
  DropEndZeroes(denom);
  Set(numer,Reverse(numer));
  Set(denom,Reverse(denom));
  Set(ln,Length(numer));
  Set(ld,Length(denom));
  Set(q,FillList(0,ln));
  Set(r,FillList(0,ln));

  Set(i,1);
  If(ld>0,
  [
    While(Length(numer)>=Length(denom))
    [
      Set(nq,numer[1]/denom[1]);
      q[ln-(Length(numer)-ld)] := nq;
      For(j:=1,j<=Length(denom),j++)
      [
        numer[j] := (numer[j] - nq*denom[j]);
      ];
      r[i] := r[1] + numer[1];

      Set(numer, Rest(numer));
      i++;
    ];
  ]);
  For(j:=0,j<Length(numer),j++)
  [
    r[i+j] := r[i+j] + numer[j+1];
  ];
  Set(q,Reverse(q));
  Set(r,Reverse(r));
  DropEndZeroes(q);
  DropEndZeroes(r);
  {q,r};
];

]; 






5  # FW(_list)_(Length(list) = 0) <-- 1;
10 # FW(_list)_(Length(list) = 1) <-- FWatom(list[1]);
20 # FW(_list) <--
[
  Local(result);
  result:=FWatom(First(list));
  ForEach(item,Rest(list))
  [
   result := ListToFunction({ ToAtom("*"),result,FWatom(item)});
  ];
  result;
];


10 # FWatom({_a,1}) <-- a;
20 # FWatom({_a,_n}) <-- ListToFunction({ToAtom("^"),a, n});




10 # Factor(p_CanBeUni) <-- FW(Factors(p));






Function("FactorQS",{n})[
	Local(x,k,fb,j);
	
	
	k:=Round(N(Sqrt(Exp(Sqrt(Ln(n)*Ln(Ln(n)))))));
	fb:=ZeroVector(k);
	For(j:=1,j<=k,j++)[
		fb[j]:=NextPrime(j);
	];
];






1# FactorizeInt(0) <-- {};
1# FactorizeInt(1) <-- {};

3# FactorizeInt(n_IsInteger) <--
[
  Local(small'powers);
  n := Abs(n);	
  
  
  If(
  	Gcd(ProductPrimesTo257(), n) > 1,	
	small'powers := TrialFactorize(n, 257),	
	small'powers := {n}	
  );
  n := small'powers[1];	
  If(n=1, Rest(small'powers),
  
	  [
	  	
		SortFactorList(
	  	  PollardCombineLists(Rest(small'powers), PollardRhoFactorize(n))
		);
	  ]
  );
];


Retract("Factors",*);
Retract("FactorsMultivariateSpecialCases",*);
Retract("FactorsSomethingElse",*);
Retract("CombineNumericalFactors",*);




 

10 # Factors(p_IsPositiveInteger) <--  FactorizeInt(p);

11 # Factors(p_IsInteger) <-- FactorizeInt(p);

12 # Factors(p_IsRational)_(Denominator(p) != 1) <-- {{Factor(Numerator(p)) /Factor(Denominator(p)) , 1}}; 
     

14 # Factors(p_IsGaussianInteger)	<-- GaussianFactors(p);

20 # Factors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  
[
    Local(x,d,coeffs,nterms,factorsList,result);
    x := VarList(p)[1];
    d := Degree(p,x);
    
    
    coeffs := Coef(p,x,0 .. Degree(p,x));
    nterms := Length(Select(coeffs, "IsNotZero"));
    
    If( nterms = 2 And d > 2, 
      [  result := FactorsBinomials(p);  ],    
      [  
        factorsList := BinaryFactors(p);
           
           
        
        If( AllSatisfy("IsInteger",coeffs),
          [
              
              result := FactorsPolynomialOverIntegers(p,x);
          ],
          [
              
              
              Local(notInt,rat,dd,lcm,newCoeffs,NewPoly,facs);
              notInt := Select(coeffs, Lambda({i},Not IsInteger(i)));
              rat := Rationalize(coeffs);            
              dd  := MapSingle("Denominator",rat);
              lcm := Lcm(dd);
              newCoeffs := lcm * rat;
              newPoly := NormalForm(UniVariate(x,0,newCoeffs));
              facs := FactorsPolynomialOverIntegers(newPoly);
              If( InVerboseMode(), [
                  Echo("coeffs ",coeffs);
                  Echo("notInt ",notInt);
                  Echo("rat ",rat);
                  Echo("dd  ",dd);
                  Echo("lcm ",lcm);
                  Echo("newCoeffs ",newCoeffs);
                  Echo("newPoly ",newPoly);
                  Echo("facs ",facs);
                 ]
              );
              result := {(1/lcm),1}:facs;
              
        ]
      );
    ]
   );
      CombineNumericalFactors( result );
];


30 # Factors(p_CanBeUni) <--  
[
    
    Local(vl,nvars,coeffs,result);
    vl     := VarList(p);
    nvars  := Length(vl);
    coeffs := Coef(p,x,0 .. 8);
    If(InVerboseMode(),Tell("CBU",{vl,nvars,coeffs}));
    If (nvars > 1, 
         [
            If( InVerboseMode(), Echo(" special ",p));
            result := FactorsMultivariateSpecialCases(p);
         ], 
            result := FactorsSomethingElse(p) 
       );
       CombineNumericalFactors( result );
];


40 # Factors(_p) <--
[
    
     If( InVerboseMode(), Echo("Possibly trying to factor polynomial with non-integral exponents") );
     Local( result);
     
     
     result := {{p,1}};
     CombineNumericalFactors( result );
     
];





10 # FactorsMultivariateSpecialCases(-_expr) <-- {-1,1}:FactorsMultivariateSpecialCases(expr);

10 # FactorsMultivariateSpecialCases(x_IsAtom + y_IsAtom) <-- [If(InVerboseMode(),Tell(1));{{x+y,1}};];

10 # FactorsMultivariateSpecialCases(x_IsAtom - y_IsAtom) <-- [If(InVerboseMode(),Tell(2));{{x-y,1}};];

10 # FactorsMultivariateSpecialCases(_n*_x^p_IsInteger + _n*_y) <-- [If(InVerboseMode(),Tell(3));{n,1}:FactorsMultivariateSpecialCases(x+y);];

10 # FactorsMultivariateSpecialCases(_n*_x^p_IsInteger - _n*_y) <-- [If(InVerboseMode(),Tell(4));{n,1}:FactorsMultivariateSpecialCases(x-y);];

10 # FactorsMultivariateSpecialCases(n_IsInteger*_x + m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x+m*y)/Gcd(n,m))),1}};

10 # FactorsMultivariateSpecialCases(n_IsInteger*_x - m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x-m*y)/Gcd(n,m))),1}};

10 # FactorsMultivariateSpecialCases(_n*_x + _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x+y);

10 # FactorsMultivariateSpecialCases(_n*_x - _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x-y);

10 # FactorsMultivariateSpecialCases(_x^n_IsInteger - _y) <-- FactorsBinomials(x^n - y); 

10 # FactorsMultivariateSpecialCases(_x^n_IsInteger + _y) <-- FactorsBinomials(x^n + y); 

20 # FactorsSomethingElse(_p) <-- 
  [
      If( InVerboseMode(),
          [
              ECHO("   *** FactorsSomethingElse: NOT IMPLEMENTED YET ***");
          ]
      );
      p;
  ];




10 # CombineNumericalFactors( factrs_IsList ) <--
  [
      If( InVerboseMode(), Tell("Combine",factrs) );
      Local(q,a,b,t,f,err);
      err := False;
      t   := 1;
      f   := {};
      ForEach(q,factrs)
      [
          If( InVerboseMode(), Tell(1,q) );
          If( IsList(q) And Length(q)=2,
              [
                  {a,b} := q;
                  If( InVerboseMode(), Echo("     ",{a,b}) );
                  If( IsNumericList( {a,b} ),
                      t := t * a^b,
                      f := {a,b}:f
                  );
              ],
              err := True
          );
      ];
      If( InVerboseMode(),
        [
            Echo("      t = ",t);
            Echo("      f = ",f);
            Echo("    err = ",err);
        ]
      );
      If(Not err And t != 1, {t,1}:Reverse(f), factrs);
  ];


Retract("FactorsBinomials",*);

10 # FactorsBinomials( _x + y_IsFreeOf(x) ) <-- {x+y,1};

10 # FactorsBinomials( _x - y_IsFreeOf(x) ) <-- {x-y,1};

10 # FactorsBinomials( c_IsConstant * _x + y_IsFreeOf(x) ) <-- {c*x+y,1};

10 # FactorsBinomials( c_IsConstant * _x - y_IsFreeOf(x) ) <-- {c*x-y,1};

10 # FactorsBinomials( _x^m_IsOdd + _y ) <--
[
    If(InVerboseMode(),Tell("FactorsBinomialssum",{x,m,y}));
    Local(nn,qq);
    nn := (m-1)/2;
    qq := (y^(1/m));
    If(InVerboseMode(),Tell("  FBinsum1",{nn,qq}));
    r := {{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}};
];


12 # FactorsBinomials( c_IsConstant * _x^m_IsOdd + _y ) <--
[
    If(InVerboseMode(),Tell("FactorsBinomialssum",{c,x,m,y}));
    Local(nn,qq);
    nn := (m-1)/2;
    qq := ((y/c)^(1/m));
    If(InVerboseMode(),Tell("  FBinsum.1b",{nn,qq}));
    If( c=1,
          r := {{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}},
          r := {{c,1},{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}}
    );  
];


10 # FactorsBinomials( _x^m_IsInteger - _y ) <--
[
    If(InVerboseMode(),Tell("FactorsBinomialsdif",{x,m,y}));
    Local(pp,qq,r,L);
    pp := m-1;
    qq := (y^(1/m));
    If(IsNumber(y),qq:=GuessRational(N(qq)));
    If(InVerboseMode(),Tell("  FBindif.1",{pp,qq}));
    
    if      (m = 2)
        [
            L := FunctionToList(y);
            If(And(L[1]=ToAtom("^"),L[3]=2),qq:=L[2]);
            r := {{x+qq,1},{x-qq,1}};
        ]
    else if (m = 4)
        [r := {{x+qq,1},{x-qq,1},{x^2+qq^2,1}};]
    else if (m = 6)
        [r := {{x+qq,1},{x-qq,1},{x^2+x*qq+qq^2,1},{x^2-x*qq+qq^2,1}};]
    else
        [r := {{x-qq,1},{Sum(k,0,pp,qq^k*x^(pp-k)),1}};];
    r;
];


12 # xFactorsBinomials( c_IsConstant * _x^m_IsInteger - _y ) <--
[
    If(InVerboseMode(),Tell("FactorsBinomialsdif",{c,x,m,y}));
    Local(aa,bb,c0,r);
    aa := c^(1/m);
    bb := ((y)^(1/m));
    If(IsNumber(y),bb:=GuessRational(N(bb)));
    If(InVerboseMode(),Tell("  FBindif.1b",{aa,bb}));
    r  := FactorsBinomials( (aa*x)^m - bb^m );
];


Retract("FactorsMonomial",*);

10 # FactorsMonomial(expr_IsMonomial) <--
[
  If(InVerboseMode(),Tell("FactorsMonomial",expr));
  Local(den,num,Ns,flat,prod,quot,result,f,ff);
  If( IsRationalFunction(expr),
    [
      den := Denominator(expr);
      num := Flatten(Numerator(expr),"*");
    ],
    [
      den := 1;
      num := Flatten(expr,"*");
    ]
  );
  If(InVerboseMode(),Tell("     ",{num,den}));
  Ns  := Select(num, "IsComplex");
  If(InVerboseMode(),Tell("     ",Ns));
  If( Ns = {},
       If( den != 1, DestructiveInsert(num,1,1/den)),
       DestructiveReplace(num,Find(num,Ns[1]),Ns[1]/den)
  );
  If(InVerboseMode(),Tell("     ",num));
  result := {};
  ForEach(f,num)
  [
      If( IsComplex(f), 
          DestructiveAppend(result,{(f),1}),
          If( IsAtom(f),
              DestructiveAppend(result,{f,1}),
              DestructiveAppend(result,DestructiveDelete(FunctionToList(f),1))
          )
      );
  ];
  result;
];


Retract("FactorsPolynomialOverIntegers",*);
Retract("TryToReduceSpecialPolynomial",*);



10 # FactorsPolynomialOverIntegers(_expr)_IsPolynomialOverIntegers(expr) <--
[
    Local(x);
    x := VarList(expr)[1];
    FactorsPolynomialOverIntegers(expr,x);

];

15 # FactorsPolynomialOverIntegers(_expr) <-- expr;


10 # FactorsPolynomialOverIntegers(_expr,_var)_(IsPolynomialOverIntegers(expr,var)) <--
[
    Local(factorsList,factListTransp,factrs,multiplicities,factrsUnMonic);
    Local(polyFactors,normalizations,normDivisor,polyFactors,factList);
    Local(n,result,newResult,gtotal,r,rr,d,g);
    factorsList := BinaryFactors(expr);
    
    
    
    
    
    
    
    factListTransp := Transpose(factorsList);
    factrs := factListTransp[1];
    multiplicities := factListTransp[2];
        
    
    
    
    
    
    
    
    
    factrsUnMonic := MapSingle("Together",factrs);
        
    
    
    
    
    
    
    
    {polyFactors,normalizations}:=Transpose(MapSingle("GetNumerDenom",factrsUnMonic));
        
    
    
    
    
    
    
    
            
    normDivisor := Product(Map("^",{normalizations,multiplicities}));
    
    
    
    
    
    
    
    
    polyFactors[1] := Simplify(polyFactors[1]/normDivisor);
    
    
    
    
    factListTransp[1] := polyFactors;
    factList := Transpose(factListTransp);
    
    
    
    result := factList;
    
    
    Local(newResult,gtotal,d,g,rr);
    newResult := {};
    gtotal    := 1;
    ForEach(r,result) [
        d := Degree(r[1],var);
        g := Gcd(Coef(r[1],var,0 .. d));
        If( g > 1,   
               [ gtotal:=g*gtotal; 
                 r[1]:=Simplify(r[1]/g);
               ]
          );
        If(d > 2,
            [
                
                rr := TryToReduceSpecialPolynomial(r[1]);
                If( IsList(rr),newResult := Concat(newResult,rr) );
            ],
                If( r != {1,1}, newResult := r:newResult )
          );
    ];  
    If(gtotal>1,newResult:={gtotal,1}:newResult);    
    newResult;
];






 
10 # TryToReduceSpecialPolynomial(_x^4+_x^2+1) <-- {{x^2+x+1,1},{x^2-x+1,1}};

10 # TryToReduceSpecialPolynomial(_x^6-1) <-- {{x+1,1},{x-1,1},{x^2+x+1,1},{x^2-x+1,1}};




Retract("FactorsSmallInteger",*);

10 # FactorsSmallInteger( N_IsInteger ) <--
[
	Local(n, power, prime, result, limit);
    n      := Abs(N);         
    limit  := Ceil(SqrtN(n)); 
	prime  := 2;	          
    result := {};
	While( prime <= limit And n > 1 And prime*prime <= n )
	[	
		{n, power} := FindPrimeFactor(n, prime);
		If(	power > 0,	DestructiveAppend(result, {prime,power}) );
		prime := NextPseudoPrime(prime);	
	];
	
	If( n > 1, DestructiveAppend(result, {n,1}) );
    result;
];







FindPrimeFactor(n, prime) :=
[
	Local(power, factor, old'factor, step);
	power := 1;
	old'factor := 1;	
	factor := prime;
	
	While(Modulo(n, factor)=0)	
	[
		old'factor := factor;	
		factor := factor^2;
		power := power*2;
	];
	power := Quotient(power,2);
	factor := old'factor;
	n := Quotient(n, factor);
	
	step := Quotient(power,2);
	While(step>0 And n > 1)
	[
		factor := prime^step;
		If(
			Modulo(n, factor)=0,
			[
				n := Quotient(n, factor);
				power := power + step;
			]
		);
		step := Quotient(step, 2);
	];
	{n, power};
];





FindPrimeFactorSimple(n, prime) :=
[
	Local(power, factor);
	power := 0;
	factor := prime;
	While(Modulo(n, factor)=0)
	[
		factor := factor*prime;
		power++;
	];
	{n/(factor/prime), power};
];


Retract("CanBeMonomial",*);
Retract("IsMonomial",*);
Retract("FactorsMonomial",*);

10 # CanBeMonomial(_expr)<--Not (HasFunc(expr,ToAtom("+")) Or HasFunc(expr,ToAtom("-")));

10 # IsMonomial(expr_CanBeMonomial) <-- 
[
    Local(r);
    If( IsRationalFunction(expr),
        r := (VarList(Denominator(expr)) = {}),
        r := True
    );
];

15 # IsMonomial(_expr) <-- False;


10 # FactorsMonomial(expr_IsMonomial) <--
[
  If(InVerboseMode(),Tell("FactorsMonomial",expr));
  Local(den,num,Ns,flat,prod,quot,result,f,ff);
  If( IsRationalFunction(expr),
    [
      den := Denominator(expr);
      num := Flatten(Numerator(expr),"*");
    ],
    [
      den := 1;
      num := Flatten(expr,"*");
    ]
  );
  If(InVerboseMode(),Tell("     ",{num,den}));
  Ns  := Select(num, "IsComplex");
  If(InVerboseMode(),Tell("     ",Ns));
  If( Ns = {},
       If( den != 1, DestructiveInsert(num,1,1/den)),
       DestructiveReplace(num,Find(num,Ns[1]),Ns[1]/den)
  );
  If(InVerboseMode(),Tell("     ",num));
  result := {};
  ForEach(f,num)
  [
      If( IsComplex(f), 
          DestructiveAppend(result,{(f),1}),
          If( IsAtom(f),
              DestructiveAppend(result,{f,1}),
              DestructiveAppend(result,DestructiveDelete(FunctionToList(f),1))
          )
      );
  ];
  result;
];




10 # Roots(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i,deg);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    deg:=Degree(uni);
    If(deg > 0 And deg < 3,
      [
        root:= PSolve(uni);
        If(Not IsList(root),root:={root});
        For(i:=0,i<item[2],i++)
          result:= Concat(root, result);
      ]
      );
  ];
  result;
];




10 # RootsWithMultiples(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i,deg);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);

    deg:=Degree(uni);
    If(deg > 0 And deg < 3,
      [
        root:= PSolve(uni);
        If(Not IsList(root),root:={root});
        For(i:=1,i<=Length(root),i++)
          result:= Concat({{root[i],item[2]}}, result);
      ]
      );
  ];
  result;
];



LocalSymbols(a,b, list) [

SortFactorList(list) := HeapSort(list, {{a,b}, a[1]<b[1]});

];















TrialFactorize(n, limit) :=
[
	Local(power, prime, result);
	result := {n};	
	prime := 2;	
	While(prime <= limit And n>1 And prime*prime <= n)
	[	
		{n, power} := FindPrimeFactor(n, prime);
		If(
			power>0,
			DestructiveAppend(result, {prime,power})
		);
		prime := NextPseudoPrime(prime);	
	];
	
	DestructiveReplace(result, 1, n);
];






Retract("xContent",*);
Retract("GetContent",*);
Retract("xPeel",*);
Retract("FinalPeel",*);

10 # xContent( expr_CanBeUni ) <--
[
    Local(vars,L,cont,result);
    vars   := VarList(expr);
    L      := Length(vars);
    result := GetContent(expr,L);    
    resid  := Simplify(expr/result);
    cont   := result * FinalPeel(resid);
];


10 # GetContent(_expr,_L)_(L=0) <-- expr;


12 # GetContent(_expr,_L)_(L=1) <--
[
    Local(uni,result);
    uni    := MakeUni(expr);
    result := NormalForm(Gcd(uni[3])*uni[1]^uni[2]);
];


14 # GetContent(_expr,_L) <--
[
    Local(cont2,lst);
    cont2  := MultiSimp(expr);
    lst    := FunctionToList(cont2);
    result := xPeel(lst);

];

UnFence("GetContent",2);


10 # xPeel(L_IsList)_(L[1] = /) <--
[
    Local(result);
    result := L[3];
    result := xPeel(FunctionToList(L[2])) / result;
];


10 # xPeel(L_IsList)_(L[1] = *) <--
[
    Local(result);
    result := L[2];
    result := xPeel(FunctionToList(L[3])) * result;
    result;
];


12 # xPeel(L_IsList) <-- 1;


10 # FinalPeel(_poly) <--
[
    Local(uni,Lu3,v,n,fac,fac2,result,p1);
    uni := MakeUni(poly);
    Lu3 := Length(uni[3]);
    v := uni[1];
    n := uni[2];
    fac := If( n > 0, v^n, 1 );
    result := fac;
    p1 := uni[3][Lu3];
    While ( Type(p1) = "UniVariate" )
    [
        v := p1[1];
        n := p1[2];
        fac2 := If( n > 0, v^n, 1 );
        If( fac2 != 1, result := result * fac2 );
        p1 := p1[3][1];
   ];
   result;
];


Retract("xFactor",*);


10 # xFactor( L_IsList ) <-- 
[
    Local (result,x,f);
    result := {};
    ForEach(x,L)
    [
        f := xFactors(x);
        If( f = {}, f := 0, f := FW(f) );
        DestructiveAppend(result,f);
    ];
    result;
];



15 # xFactor( _expr ) <-- expr;




Retract("xFactors",*);
Retract("xPolyFactors",*);
Retract("xFactorsMultivariateSpecialCases",*);
Retract("xFactorsSomethingElse",*);
Retract("CombineNumericalFactors",*);






10 # xFactors( L_IsList ) <-- xFactors /@ L;




10 # xFactors(p_IsPositiveInteger) <--  
[
    If( p < 1600, FactorsSmallInteger(p), FactorizeInt(p) );
];

10 # xFactors(p_IsNegativeInteger) <-- xFactors(-p);

10 # xFactors(p_IsRational)_(Denominator(p) != 1) <-- 
             { {xFactor(Numerator(p)) / xFactor(Denominator(p) ) , 1} }; 

10 # xFactors(p_IsGaussianInteger)	<-- GaussianFactors(p);





21 # xFactors( poly_CanBeUni ) <--
[
    If(InVerboseMode(),Tell("xFactors_can_be_uni",poly));
    Local(content,pp,vars,nvars,ppFactors,monomialFactors,result);
    
    
    Unbind(content);
    pp := xPrimitivePart( poly, content );
    If(InVerboseMode(),Tell("  ",{content,pp}));
    
    
    
    vars  := VarList(pp);
    nvars := Length(vars);
    
    If(InVerboseMode(),Tell("  ",vars));
    ppFactors := xPolyFactors( pp );
    If(InVerboseMode(),Tell("  ",ppFactors));
    If( ppFactors = True, ReturnFromBlock(-9999) ); 
    
    
    monomialFactors := FactorsMonomial(content);
    If(InVerboseMode(),Tell("  ",monomialFactors));
    If( monomialFactors[1][1] = 1,
        result := ppFactors,        
        result := Concat(monomialFactors,ppFactors)
    );
    If(InVerboseMode(),Tell("  ",result));
    result;
];



10 # xPolyFactors( _poly )_(nvars=1) <--
[
    Local(factrs,uni,deg,coeffs,hasRealCoeffs);
    If(InVerboseMode(),Tell("xFactors_uni",poly));
    
    
    uni := MakeUni(poly);
    If(InVerboseMode(),Tell("  ",uni));
    coeffs := uni[3]; 
    deg    := Length(coeffs)-1;
    If(InVerboseMode(),Tell("       ",{deg,coeffs}));
    hasRealCoeffs := Length(Select(coeffs, "IsDecimal")) > 0;
    If(InVerboseMode(),Tell("       ",hasRealCoeffs));
    
    
    If( hasRealCoeffs,
      [
          coeffs := Rationalize(coeffs);
          If(InVerboseMode(),Tell("      Z",coeffs));
          gcd    := Gcd(coeffs);
          If(InVerboseMode(),Tell("       ",gcd));
          If( gcd != 1,
            [
              coeffs  := Simplify(coeffs/gcd);
              content := content * gcd;
              If(InVerboseMode(),Tell("          ",{content,coeffs}));
            ]
          );
          poly := NormalForm(UniVariate(uni[1],uni[2],coeffs));
          If(InVerboseMode(),Tell("   new",poly));
      ]
    );
    
    
    
    factrs := BinaryFactors(poly);
    If(InVerboseMode(),Tell("       ",Type(factrs)));
    factrs;
];




10 # xPolyFactors( _poly )_(nvars=2) <--
[
    If(InVerboseMode(),Tell("xFactors_bivariate",poly));
    Local(primeInteger,result1);
    If(InVerboseMode(),Tell("   ",vars));
    
    primeInteger := 7247;
    If(InVerboseMode(),Tell("    random",primeInteger));
    upoly := Subst(vars[2],primeInteger) poly;
    If(InVerboseMode(),Tell("   ",upoly));
    result1 := xFactors(upoly);
    If(InVerboseMode(),Tell(" ",result1));
    ForEach(s,result1)
    [
        If(InVerboseMode(),Tell("      ",s));
        
        us := MakeUni(s[1]);
        
        cs := us[3];
        
        fs := FactorizeInt /@ cs;
        
        result2 := (Subst(primeInteger,vars[2])fs);
        
        ii := Find(result2,{});
        
        If(ii > 0, DestructiveDelete(result2,ii));
        
        s1 := FW(result2[1]);
        If(InVerboseMode(),Tell("      ",s1));
        
    ];
    
    
    
];




10 # xPolyFactors( _poly )_(nvars>2) <--
[
    If(InVerboseMode(),Tell("xFactors_multi",poly));
    If(InVerboseMode(),Tell("   ",vars));
    
];

UnFence("xPolyFactors",1);






Retract("xPrimitivePart",*);
    
10 # xPrimitivePart(poly_CanBeUni) <-- 
[
    Local(cont,pp);
    cont := xContent(poly);
    pp   := Simplify(Simplify(poly/cont));
];


Macro("xPrimitivePart",{poly,xcont})
[
    If( IsBound(@xcont), 
      [
          result := Simplify(Simplify(Eval(@poly)/Eval(@xcont)));
      ],
      [
          xCont  := xContent(Eval(@poly));
          @xcont := xCont;
          result := Simplify(Simplify(Eval(@poly)/xCont));
      ]
    );
    result;
];

