
LocalSymbols(lastcoef,OrdBuild, AddFoundSolutionSingle , AddFoundSolution, Fct, MkfactD)
[

LastCoef(_vector,_p) <--
[
  Local(n);
  n:=Length(vector);
  Add(vector*p^(0 .. (n-1)));
];



OrdBuild(vector,q):=
[
  Local(i,result,n);
  Set(i,2);
  Set(result, 0);
  Set(n, Length(vector));
  While (i<=n)
  [
    Set(result,result+(i-1)*vector[i]*p^(i-2));
    Set(i, i+2);
  ];
  q*result;
];


Function(AddFoundSolutionSingle,{p})
[
  Local(calc);


    Set(calc, Eval(lastcoef));
    If (Equals(calc, 0),
    [
      Local(newlist,count,root);
      count:=0;
      root := p;
      Local(rem);

      rem:={-root,1};
      {testpoly,rem}:=MkfactD(testpoly,rem);

      rem:={-root,1};
      {newlist,rem}:=MkfactD(poly,rem);
      While (rem = {})
      [
        count++;
        Set(poly,newlist);
        rem:={-root,1};
        {newlist,rem}:=MkfactD(poly,rem);
      ];

      Local(lgcd,lc);
      Set(lgcd,Gcd({andiv,an,root}));
      Set(lc,Div(an,lgcd));
      Set(result,{var+ (-(Div(root,lgcd)/lc)),count}:result);
      Set(andiv,Div(andiv,lgcd^count));
      Set(anmul,anmul*lc^count);




      Local(p,q);
      Set(lastcoef, LastCoef(testpoly,p));
      Set(ord, OrdBuild(testpoly,q));
    ]);

];
UnFence(AddFoundSolutionSingle,1);

Function(AddFoundSolution,{p})
[
  AddFoundSolutionSingle(p);
  AddFoundSolutionSingle(-2*q+p);
];
UnFence(AddFoundSolution,1);

Function(Fct,{poly,var})
[
  Local(maxNrRoots,result,ord,p,q,accu,calc,twoq,mask);

  Local(gcd);
  [
    Set(gcd,Gcd(poly));
    If(poly[Length(poly)] < 0,Set(gcd, gcd * -1));
    Set(poly,poly/gcd);
  ];

  Local(unrat);
  Set(unrat,Lcm(MapSingle("Denominator",poly)));
  Set(poly,unrat*poly);

  Local(origdegree);
  Set(origdegree,Length(poly)-1);

  Local(an,andiv,anmul);
  Set(an,poly[Length(poly)]);
  Set(poly,poly* (an^((origdegree-1) .. -1)));
  Set(andiv,an^(origdegree-1));
  Set(anmul,1);

  Local(leadingcoef,lowestcoef);
  Set(leadingcoef,poly[Length(poly)]);
  [
    Local(i);
    Set(i,1);
    Set(lowestcoef,Abs(poly[i]));
    While (lowestcoef = 0 And i<=Length(poly))
    [
      Set(i,i+1);
      Set(lowestcoef,Abs(poly[i]));
    ];
  ];
  
  
  
  Local(testpoly);

  Local(deriv);
  
  deriv:=Rest(poly);
  [
    Local(i);
    For (i:=1,i<=Length(deriv),i++)
    [
      deriv[i] := deriv[i]*i;
    ];


  ];
  [
    Local(q,r,next);
    q:=poly;
    r:=deriv;
    While(r != {})
    [

      next := MkfactD(q,r)[2];
      q:=r;
      r:=next;
    ];
    

    
    q:=q/q[Length(q)];
    testpoly:=MkfactD(poly,q)[1];

  ];



  Set(maxNrRoots,Length(testpoly)-1);
  Set(result, {});

  Set(lastcoef, LastCoef(testpoly,p));
  Set(ord, OrdBuild(testpoly,q));

  Set(accu,{});
  Set(q,1);
  Set(twoq,MultiplyN(q,2));
  Set(mask,AddN(twoq,MathNegate(1)));
  if (IsEven(testpoly[1]))
  [
    Set(accu,0:accu);
    AddFoundSolutionSingle(0);
  ];
  Set(p,1);
  Set(calc, Eval(lastcoef));
  If (IsEven(calc),
  [
    Set(accu,1:accu);
    AddFoundSolution(1);
  ]);
  Set(q,twoq);
  Set(twoq,MultiplyN(q,2));
  Set(mask,AddN(twoq,MathNegate(1)));
  While(Length(result)<maxNrRoots And Length(accu)>0 And q<=Abs(testpoly[1]))
  [
    Local(newaccu);
    Set(newaccu,{});
    ForEach(p,accu)
    [
      Set(calc,Eval(lastcoef));
      If (LessThan(calc,0),
        Set(calc, AddN(calc,MultiplyN(twoq,DivN(AddN(MathNegate(calc),twoq),twoq))))
         );
      Set(calc, BitAnd(calc, mask));
      If ( Equals(calc, 0),
      [
        Set(newaccu, p:newaccu);
        AddFoundSolutionSingle(-2*q+p);
      ]);
      Set(calc, AddN(calc, Eval(ord)));
      If (LessThan(calc,0),
        Set(calc, AddN(calc,MultiplyN(twoq,DivN(AddN(MathNegate(calc),twoq),twoq))))
         );
      Set(calc, BitAnd(calc, mask));
      If ( Equals(calc, 0),
      [
        Set(newaccu, AddN(p,q):newaccu);
        AddFoundSolution(AddN(p,q));
      ]);
    ];
    Set(accu, newaccu);
    Set(q,twoq);
    Set(twoq,MultiplyN(q,2));
    Set(mask,AddN(twoq,MathNegate(1)));




  ];

  
  
  Set(poly,poly*an^(0 .. (Length(poly)-1)));
  Set(poly,gcd*anmul*poly);
  
  If(Not IsZero(unrat * andiv ),Set(poly,poly/(unrat * andiv )));
  If(poly != {1},
  [
    result:={(Add(poly*var^(0 .. (Length(poly)-1)))),1}:result;
  ]);
  result;
];



BinaryFactors(expr):=
[
  Local(result,uni,coefs);
  uni:=MakeUni(expr,VarList(expr)[1]);
  uni:=Listify(uni);
  coefs:=uni[4];
  coefs:=Concat(ZeroVector(uni[3]),coefs);
  result:=Fct(coefs,uni[2]);



  result;
];



MkfactD(numer,denom):=
[
  Local(q,r,i,j,ln,ld,nq);
  DropEndZeroes(numer);
  DropEndZeroes(denom);
  Set(numer,Reverse(numer));
  Set(denom,Reverse(denom));
  Set(ln,Length(numer));
  Set(ld,Length(denom));
  Set(q,FillList(0,ln));
  Set(r,FillList(0,ln));

  Set(i,1);
  If(ld>0,
  [
    While(Length(numer)>=Length(denom))
    [
      Set(nq,numer[1]/denom[1]);
      q[ln-(Length(numer)-ld)] := nq;
      For(j:=1,j<=Length(denom),j++)
      [
        numer[j] := (numer[j] - nq*denom[j]);
      ];
      r[i] := r[1] + numer[1];

      Set(numer, Rest(numer));
      i++;
    ];
  ]);
  For(j:=0,j<Length(numer),j++)
  [
    r[i+j] := r[i+j] + numer[j+1];
  ];
  Set(q,Reverse(q));
  Set(r,Reverse(r));
  DropEndZeroes(q);
  DropEndZeroes(r);
  {q,r};
];

]; 






5  # FW(_list)_(Length(list) = 0) <-- 1;
10 # FW(_list)_(Length(list) = 1) <-- FWatom(list[1]);
20 # FW(_list) <--
[
  Local(result);
  result:=FWatom(First(list));
  ForEach(item,Rest(list))
  [
   result := UnList({ Atom("*"),result,FWatom(item)});
  ];
  result;
];


10 # FWatom({_a,1}) <-- a;
20 # FWatom({_a,_n}) <-- UnList({Atom("^"),a, n});




10 # Factor(p_CanBeUni) <-- FW(Factors(p));






Function("FactorQS",{n})[
	Local(x,k,fb,j);
	
	
	k:=Round(N(Sqrt(Exp(Sqrt(Ln(n)*Ln(Ln(n)))))));
	fb:=ZeroVector(k);
	For(j:=1,j<=k,j++)[
		fb[j]:=NextPrime(j);
	];
];






1# FactorizeInt(0) <-- {};
1# FactorizeInt(1) <-- {};

3# FactorizeInt(n_IsInteger) <--
[
  Local(small'powers);
  n := Abs(n);	
  
  
  If(
  	Gcd(ProductPrimesTo257(), n) > 1,	
	small'powers := TrialFactorize(n, 257),	
	small'powers := {n}	
  );
  n := small'powers[1];	
  If(n=1, Rest(small'powers),
  
	  [
	  	If(InVerboseMode(), Echo({"FactorizeInt: Info: remaining number ", n}));
		SortFactorList(
	  	  PollardCombineLists(Rest(small'powers), PollardRhoFactorize(n))
		);
	  ]
  );
];


Retract("Factors",*);
Retract("FactorsMultivariateSpecialCases",*);
Retract("FactorsSomethingElse",*);
Retract("CombineNumericalFactors",*);



10 # Factors(p_IsPositiveInteger) <--  FactorizeInt(p);

11 # Factors(p_IsInteger) <-- FactorizeInt(p);
     

12 # Factors(p_IsRational)_(Denominator(p) != 1) <-- {{Factor(Numerator(p)) /Factor(Denominator(p)) , 1}}; 
     

14 # Factors(p_IsGaussianInteger)	<-- GaussianFactors(p);

20 # Factors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  
[
    Local(x,coeffs,factorsList,result);
    x := VarList(p)[1];
    
    
    factorsList := BinaryFactors(p);
         
         
    
    coeffs := Coef(p,x,0 .. Degree(p,x));
    If( AllSatisfy("IsInteger",coeffs),
        [
            
            result := FactorsPolynomialOverIntegers(p,x);
        ],
        [
            
            
            Local(notInt,rat,dd,lcm,newCoeffs,NewPoly,facs);
            notInt := Select(Lambda({i},Not IsInteger(i)),coeffs);
            rat := Rationalize(coeffs);            
            dd  := MapSingle("Denominator",rat);
            lcm := Lcm(dd);
            newCoeffs := lcm * rat;
            newPoly := NormalForm(UniVariate(x,0,newCoeffs));
            facs := FactorsPolynomialOverIntegers(newPoly);
            If( iDebugF=True, [
                  Echo("coeffs ",coeffs);
                  Echo("notInt ",notInt);
                  Echo("rat ",rat);
                  Echo("dd  ",dd);
                  Echo("lcm ",lcm);
                  Echo("newCoeffs ",newCoeffs);
                  Echo("newPoly ",newPoly);
                  Echo("facs ",facs);
                ]
              );
            result := {(1/lcm),1}:facs;
            
        ]
      );
      CombineNumericalFactors( result );
];


30 # Factors(p_CanBeUni) <--  
[
    
    Local(nvars,result);
    nvars := Length(VarList(p));
    If (nvars > 1, 
         [
            If( iDebugF=True,
                [
                    Echo("special ",p);
                    Echo(Coef(p,x,0 .. 8));
                ]
            );
            result := FactorsMultivariateSpecialCases(p);
         ], 
            result := FactorsSomethingElse(p) 
       );
       CombineNumericalFactors( result );
];


40 # Factors(_p) <--
[
    
     If( iDebugF=True, Echo("Possibly trying to factor polynomial with non-integral exponents") );
     Local( result);
     
     
     result := {{p,1}};
     CombineNumericalFactors( result );
     
];





10 # FactorsMultivariateSpecialCases(-_expr) <-- {-1,1}:FactorsMultivariateSpecialCases(expr);

10 # FactorsMultivariateSpecialCases(x_IsAtom + y_IsAtom) <-- {{x+y,1}};

10 # FactorsMultivariateSpecialCases(x_IsAtom - y_IsAtom) <-- {{x-y,1}};

10 # FactorsMultivariateSpecialCases(n_IsInteger*_x + m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x+m*y)/Gcd(n,m))),1}};

10 # FactorsMultivariateSpecialCases(n_IsInteger*_x - m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x-m*y)/Gcd(n,m))),1}};

10 # FactorsMultivariateSpecialCases(_n*_x + _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x+y);

10 # FactorsMultivariateSpecialCases(_n*_x - _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x-y);

10 # FactorsMultivariateSpecialCases(_x^2-_y^2) <-- {{x+y,1},{x-y,1}};

10 # FactorsMultivariateSpecialCases(_x^3-_y^3) <-- {{x-y,1},{x^2+y*x+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^3+_y^3) <-- {{x+y,1},{x^2-y*x+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^4-_y^4) <-- {{x+y,1},{x-y,1},{x^2+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^6-_y^6) <-- {{x+y,1},{x-y,1},{x^2+x*y+y^2,1},{x^2-x*y+y^2,1}};

20 # FactorsSomethingElse(_p) <-- 
  [
      If( iDebugF=True,
          [
              ECHO("   *** FactorsSomethingElse: NOT IMPLEMENTED YET ***");
          ]
      );
      p;
  ];




10 # CombineNumericalFactors( factrs_IsList ) <--
  [
      If( iDebugF=True, Tell("Combine",factrs) );
      Local(q,a,b,t,f,err);
      err := False;
      t   := 1;
      f   := {};
      ForEach(q,factrs)
      [
          If( iDebugF=True, Tell(1,q) );
          If( IsList(q) And Length(q)=2,
              [
                  {a,b} := q;
                  If( iDebugF=True, Echo("     ",{a,b}) );
                  If( IsNumericList( {a,b} ),
                      t := t * a^b,
                      f := {a,b}:f
                  );
              ],
              err := True
          );
      ];
      If( iDebugF=True,
        [
            Echo("      t = ",t);
            Echo("      f = ",f);
            Echo("    err = ",err);
        ]
      );
      If(Not err And t != 1, {t,1}:Reverse(f), factrs);
  ];



Retract("FactorsPolynomialOverIntegers",*);
Retract("TryToReduceSpecialPolynomial",*);



10 # FactorsPolynomialOverIntegers(_expr)_IsPolynomialOverIntegers(expr) <--
[
    Local(x);
    x := VarList(expr)[1];
    FactorsPolynomialOverIntegers(expr,x);

];

15 # FactorsPolynomialOverIntegers(_expr) <-- expr;


10 # FactorsPolynomialOverIntegers(_expr,_var)_(IsPolynomialOverIntegers(expr,var)) <--
[
    Local(factorsList,factListTransp,factrs,multiplicities,factrsUnMonic);
    Local(polyFactors,normalizations,normDivisor,polyFactors,factList);
    Local(n,result,newResult,gtotal,r,rr,d,g);
    factorsList := BinaryFactors(expr);
    
    
    
    
    
    
    
    factListTransp := Transpose(factorsList);
    factrs := factListTransp[1];
    multiplicities := factListTransp[2];
        
    
    
    
    
    
    
    
    
    factrsUnMonic := MapSingle("Together",factrs);
        
    
    
    
    
    
    
    
    {polyFactors,normalizations}:=Transpose(MapSingle("GetNumerDenom",factrsUnMonic));
        
    
    
    
    
    
    
    
            
    normDivisor := Product(Map("^",{normalizations,multiplicities}));
    
    
    
    
    
    
    
    
    polyFactors[1] := Simplify(polyFactors[1]/normDivisor);
    
    
    
    
    factListTransp[1] := polyFactors;
    factList := Transpose(factListTransp);
    
    
    
    result := factList;
    
    
    Local(newResult,gtotal,d,g,rr);
    newResult := {};
    gtotal    := 1;
    ForEach(r,result) [
        d := Degree(r[1],var);
        g := Gcd(Coef(r[1],var,0 .. d));
        If( g > 1,   
               [ gtotal:=g*gtotal; 
                 r[1]:=Simplify(r[1]/g);
               ]
          );
        If(d > 2,
            [
                
                rr := TryToReduceSpecialPolynomial(r[1]);
                If( IsList(rr),newResult := Concat(newResult,rr) );
            ],
                If( r != {1,1}, newResult := r:newResult )
          );
    ];  
    If(gtotal>1,newResult:={gtotal,1}:newResult);    
    newResult;
];






 
10 # TryToReduceSpecialPolynomial(_x^4+_x^2+1) <-- {{x^2+x+1,1},{x^2-x+1,1}};

10 # TryToReduceSpecialPolynomial(_x^6-1) <-- {{x+1,1},{x-1,1},{x^2+x+1,1},{x^2-x+1,1}};









FindPrimeFactor(n, prime) :=
[
	Local(power, factor, old'factor, step);
	power := 1;
	old'factor := 1;	
	factor := prime;
	
	While(Mod(n, factor)=0)	
	[
		old'factor := factor;	
		factor := factor^2;
		power := power*2;
	];
	power := Div(power,2);
	factor := old'factor;
	n := Div(n, factor);
	
	step := Div(power,2);
	While(step>0 And n > 1)
	[
		factor := prime^step;
		If(
			Mod(n, factor)=0,
			[
				n := Div(n, factor);
				power := power + step;
			]
		);
		step := Div(step, 2);
	];
	{n, power};
];





FindPrimeFactorSimple(n, prime) :=
[
	Local(power, factor);
	power := 0;
	factor := prime;
	While(Mod(n, factor)=0)
	[
		factor := factor*prime;
		power++;
	];
	{n/(factor/prime), power};
];




10 # Roots(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i,deg);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    deg:=Degree(uni);
    If(deg > 0 And deg < 3,
      [
        root:= PSolve(uni);
        If(Not IsList(root),root:={root});
        For(i:=0,i<item[2],i++)
          result:= Concat(root, result);
      ]
      );
  ];
  result;
];




10 # RootsWithMultiples(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i,deg);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);

    deg:=Degree(uni);
    If(deg > 0 And deg < 3,
      [
        root:= PSolve(uni);
        If(Not IsList(root),root:={root});
        For(i:=1,i<=Length(root),i++)
          result:= Concat({{root[i],item[2]}}, result);
      ]
      );
  ];
  result;
];



LocalSymbols(a,b, list) [

SortFactorList(list) := HeapSort(list, {{a,b}, a[1]<b[1]});

];















TrialFactorize(n, limit) :=
[
	Local(power, prime, result);
	result := {n};	
	prime := 2;	
	While(prime <= limit And n>1 And prime*prime <= n)
	[	
		{n, power} := FindPrimeFactor(n, prime);
		If(
			power>0,
			DestructiveAppend(result, {prime,power})
		);
		prime := NextPseudoPrime(prime);	
	];
	
	DestructiveReplace(result, 1, n);
];




Test() := Echo("Hello");

