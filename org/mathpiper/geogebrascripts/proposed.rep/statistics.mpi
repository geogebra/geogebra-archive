







AlphaToChiSquareScore(p, df) :=
[
    Local(ChiEpsilon, ChiMax, minchisq, maxchisq, chisqval, result);
    
    ChiEpsilon := 0.000001;   
    
    ChiMax := 99999.0;        
    
    minchisq := 0.0;
    
    maxchisq := ChiMax;
    
    p := N(p);
    
    if( p <= 0.0 Or p >= 1.0)
    [
    
        if (p <= 0.0) 
        [
            result := maxchisq;
        ] 
        else 
        [
            if (p >= 1.0) 
            [
                result := 0.0;
            ];
        ];
    
    ]
    else
    [
        chisqval := N(df / SqrtN(p));
        
        
        While ((maxchisq - minchisq) > ChiEpsilon) 
        [
            if (ChiSquareScoreToAlpha(chisqval, df) < p) 
            [
                maxchisq := chisqval;
            ] 
            else 
            [
                minchisq := chisqval;
            ];
            chisqval := (maxchisq + minchisq) * 0.5;
        ];
        
        result := chisqval;
    
    ];
    
    N(result);
];




AnovaCompletelyRandomizedBlock(levelsList, alpha) :=
[
    Check(IsMatrix(levelsList), "The first argument must be a list of equal-length lists.");
    
    Check(alpha >= 0 And alpha <= 1, "The second argument must be a number between 0 and 1.");
    
    Local(
        topOfSummary,
        anovaBlockTableRow1,
        criticalFScore,
        anovaBlockTableRow3,
        anovaBlockTableRow2,
        lengthsList,
        summaryTableRow,
        sumsList,
        meanSquareWithin,
        topOfPage,
        htmlJavaString,
        index,
        variancesList,
        grandMean,
        row,
        topOfAnovaBlock,
        result,
        fScoreBlock,
        criticalFScoreBlock,
        blockMeansList,
        sumOfSquaresWithin',
        meanSquareBetween,
        sumOfSquaresBetween,
        fScore,
        summaryTableRows,
        meansList,
        sumOfSquaresBlock,
        b,
        blockSummaryTableRow,
        bottomOfAnovaBlock,
        sumOfSquaresWithin,
        bottomOfPage,
        k,
        sumOfSquaresTotal,
        meanSquareBlock,
        bottomOfSummary
    );
    
    meansList := {};
    
    variancesList := {};
    
    sumsList := {};
    
    lengthsList := {};
    
    
    
    ForEach(levelList, levelsList)
    [
        meansList := meansList : N(Mean(levelList));
        
        variancesList := variancesList : N(UnbiasedVariance(levelList));
        
        sumsList := sumsList : N(Sum(levelList));

        lengthsList := lengthsList : Length(levelList);
    ];
    
    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);

    grandMean := N(Mean(meansList));
    
    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);
    
    
    
    
    blockMeansList := {};
    
    index := 1;
    
    While(index <= Length(First(levelsList)) )
    [
        row := MatrixColumn(levelsList, index);
        
        blockMeansList := Append(blockMeansList,N(Mean(row)));
    
        index++;
    ];
    
    b := Length(blockMeansList);
    
    k := Length(levelsList);
    
    sumOfSquaresBlock := Sum(j,1,b, k*(blockMeansList[j] - grandMean)^2);
    
    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);
    
    sumOfSquaresWithin' := N(sumOfSquaresTotal - sumOfSquaresBetween - sumOfSquaresBlock);
    
    meanSquareBetween := N(sumOfSquaresBetween/(k - 1));
    
    meanSquareWithin := N(sumOfSquaresWithin'/((k - 1)*(b - 1)));
    
    fScore := N(meanSquareBetween/meanSquareWithin);
    
    meanSquareBlock := N(sumOfSquaresBlock/(b - 1));
    
    fScoreBlock := N(meanSquareBlock/meanSquareWithin);
    
    criticalFScore := ProbabilityToFScore(k - 1, (k - 1)*(b - 1), 1-alpha);
    
    criticalFScoreBlock := ProbabilityToFScore(b - 1, (k - 1)*(b - 1), 1-alpha);
    
    
    
    topOfPage :=
"
    <html>
        <title>
            Anova: Completely Randomized Block
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Anova: Completely Randomized Block</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD> <?Write(ToAtom(ToString(Level):ToString(index)));?> </TD> <TD align=\"right\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>":Nl();
    
    
    
    index := 1;
    
    While(index <= Length(levelsList))
    [
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    

    
    
    blockSummaryTableRow := "<TR> <TD> <?Write(ToAtom(\"Block\":ToString(index)));?> </TD> <TD align=\"right\"> <?Write(Length(row));?> </TD> <TD> <?Write(N(Sum(row)));?> </TD>  <TD> <?Write(N(Mean(row)));?> </TD> <TD> <?Write(N(UnbiasedVariance(row)));?> </TD> </TR>":Nl();

    index := 1;
    
    While(index <= Length(First(levelsList)) )
    [
        row := MatrixColumn(levelsList, index);
        
        summaryTableRows := summaryTableRows : PatchString(blockSummaryTableRow);
    
        index++;
    ];
    
    
    
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    


    topOfAnovaBlock :=
"
            <br \>
            <br \>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>ANOVA: Completely Randomized Block</h3>  </CAPTION>
                
                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square </TH> <TH> F </TH> <TH> F Critical </TH> </TR>
";

    
    
    anovaBlockTableRow1 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Levels\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(k - 1);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>":Nl());
    
    anovaBlockTableRow2 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Blocks\"));?> </TD> <TD > <?Write(sumOfSquaresBlock);?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareBlock);?> </TD> <TD> <?Write(fScoreBlock);?> </TD> <TD> <?Write(criticalFScoreBlock);?> </TD> </TR>":Nl());

    anovaBlockTableRow3 := PatchString("<TR> <TD> <?Write(ToAtom(\"Within Levels\"));?> </TD> <TD > <?Write(sumOfSquaresWithin');?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>":Nl());

    bottomOfAnovaBlock :=
"
            </TABLE>
";


    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                topOfAnovaBlock : 
                anovaBlockTableRow1 : 
                anovaBlockTableRow2 : 
                anovaBlockTableRow3 : 
                bottomOfAnovaBlock :
                bottomOfPage);
                
                
                
     result := {};
     
     result["html"] := htmlJavaString;
     
     result["sumOfSquaresWithin'"] := sumOfSquaresWithin';
     
     result["sumOfSquaresBetween"] := sumOfSquaresBetween;
     
     result["sumOfSquaresBlock"] := sumOfSquaresBlock;
     
     result["sumOfSquaresTotal"] := sumOfSquaresTotal;
     
     result["meanSquareBetween"] := meanSquareBetween;
     
     result["meanSquareWithin"] := meanSquareWithin;
     
     result["meanSquareBlock"] := meanSquareBlock;
     
     result["fScore"] := fScore;
     
     result["criticalFScore"] := criticalFScore;
     
     result["fScoreBlock"] := fScoreBlock;
     
     result["criticalFScoreBlock"] := criticalFScoreBlock;
     
     result;
];



Retract("AnovaSingleFactor",*);

AnovaSingleFactor(levelsList, alpha) :=
[
    Check(IsListOfLists(levelsList), "The first argument must be a list of lists.");
    
    Check(alpha >= 0 And alpha <= 1, "The second argument must be a number between 0 and 1.");
    
    Local(
        anovaTableRow1,
        anovaTableRow2,
        anovaTableRow3,
        anovaTableTotal,
        bottomOfAnova,
        bottomOfPage,
        bottomOfSummary,
        criticalFScore,
        degreesOfFreedomBetween,
        degreesOfFreedomWithin,
        fScore,
        grandMean,
        htmlJavaString,
        index,
        lengthsList,
        meansList,
        meanSquareBetween,
        meanSquareWithin,
        result,
        summaryTableRow,
        summaryTableRows,
        sumOfSquaresBetween,
        sumOfSquaresTotal,
        sumOfSquaresWithin,
        sumsList,
        topOfAnova,
        topOfPage,
        topOfSummary,
        variancesList);

    meansList := {};
    
    variancesList := {};
    
    sumsList := {};
    
    lengthsList := {};
    
    ForEach(levelList, levelsList)
    [
        meansList := meansList : N(Mean(levelList));
        
        variancesList := variancesList : N(UnbiasedVariance(levelList));
        
        sumsList := sumsList : N(Sum(levelList));

        lengthsList := lengthsList : Length(levelList);
    ];
    
    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);

    grandMean := N(Mean(Flatten(levelsList, "List")));
    
    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);
    
    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);
    
    degreesOfFreedomBetween := (Length(levelsList)-1);
    
    degreesOfFreedomWithin := (ElementCount(levelsList) - Length(levelsList));
    
    meanSquareBetween := N(sumOfSquaresBetween/degreesOfFreedomBetween);
    
    meanSquareWithin := N(sumOfSquaresWithin/degreesOfFreedomWithin);
    
    fScore := N(meanSquareBetween/meanSquareWithin);
    
    criticalFScore := ProbabilityToFScore(degreesOfFreedomBetween, degreesOfFreedomWithin, 1-alpha);
    
    topOfPage :=
"
    <html>
        <title>
            Anova: Single Factor
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Anova: Single Factor</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD> <?Write(ToAtom(\"Level\":ToString(index)));?> </TD> <TD align=\"right\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>":Nl();
    
    index := 1;
    While(index <= Length(levelsList))
    [
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    


    topOfAnova :=
"
            <br \>
            <br \>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>ANOVA</h3>  </CAPTION>
                
                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square Between </TH> <TH> F </TH> <TH> F Critical </TH> </TR>
";

    
    
    anovaTableRow1 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Levels\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(degreesOfFreedomBetween);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>":Nl());
    
    anovaTableRow2 := PatchString("<TR> <TD> <?Write(ToAtom(\"Within Levels\"));?> </TD> <TD > <?Write(sumOfSquaresWithin);?> </TD> <TD> <?Write(degreesOfFreedomWithin);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>":Nl());
    
    anovaTableTotal := PatchString("<TR> <TD> Total </TD> <TD> <?Write(sumOfSquaresTotal);?> </TD> <TD> <?Write(degreesOfFreedomBetween + degreesOfFreedomWithin)?> </TD> </TR>");
    
    bottomOfAnova :=
"
            </TABLE>
";


    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                topOfAnova : 
                anovaTableRow1 : 
                anovaTableRow2 : 
                anovaTableTotal : 
                bottomOfAnova : 
                bottomOfPage);
                
                
                
     result := {};
     
     result["html"] := htmlJavaString;
     
     result["sumOfSquaresWithin"] := sumOfSquaresWithin;
     
     result["sumOfSquaresBetween"] := sumOfSquaresBetween;
     
     result["sumOfSquaresTotal"] := sumOfSquaresTotal;
     
     result["degreesOfFreedomBetween"] := degreesOfFreedomBetween;
     
     result["degreesOfFreedomWithin"] := degreesOfFreedomWithin;
     
     result["meanSquareBetween"] := meanSquareBetween;
     
     result["meanSquareWithin"] := meanSquareWithin;
     
     result["fScore"] := fScore;
     
     result["criticalFScore"] := criticalFScore;
     
     result;
];



Retract("BinomialDistributionMean", *);

BinomialDistributionMean(probability,numberOfTrials) :=
[

    Check(IsRationalOrNumber(probability) And p >= 0 And p <= 1, "The first argument must be a number between 0 and 1.");
    
    Check(IsInteger(numberOfTrials) And numberOfTrials >= 0, "The second argument must be an integer which is greater than 0.");
    
    numberOfTrials * probability;
];
	



Retract("BinomialDistributionStandardDeviation", *);

BinomialDistributionStandardDeviation(probability,numberOfTrials) :=
[

    Check(IsRationalOrNumber(probability) And p >= 0 And p <= 1, "The first argument must be a number between 0 and 1.");
    
    Check(IsInteger(numberOfTrials) And numberOfTrials >= 0, "The second argument must be an integer which is greater than 0.");
    
    SqrtN(numberOfTrials * probability * (1 - probability));
];
	







ChiSquareScoreToAlpha(score, degreesOfFreedom) :=
[
    Local(a, y, s, e, c, z, LogSqrtPi, ISqrtPi,result);                     
    
    y := 0;
    
    LogSqrtPi := 0.5723649429247000870717135; 
    
    ISqrtPi := 0.5641895835477562869480795;   
    
    if(score <= 0.0 Or degreesOfFreedom < 1) 
    [
        result := 1.0;
    ]
    else
    [
        a := N(0.5 * score);
        
        if (degreesOfFreedom > 1) 
        [
            y := If(-a < -20, 0, ExpN(-a));
        ];
        
        s := If(IsEven(degreesOfFreedom), y , (2.0 * ZScoreToProbability(-SqrtN(score))));
        
        if (degreesOfFreedom > 2) 
        [
            score := 0.5 * (degreesOfFreedom - 1.0);
            
            z := If(IsEven(degreesOfFreedom), 1.0, 0.5);
            
            if (a > 20) 
            [
                e := If(IsEven(degreesOfFreedom), 0.0, LogSqrtPi);
                
                c := LogN(a);
                
                While(z <= score) 
                [
                    e := LogN(z) + e;
                    s := s + If(c * z - a - e < -20, 0, ExpN(c * z - a - e));
                    z := z + 1.0;
                ];
                result := s;
            ] 
            else 
            [
                e := If(IsEven(degreesOfFreedom) , 1.0, (ISqrtPi / SqrtN(a)));
                
                c := 0.0;
                
                While(z <= score) 
                [
                    e := e * (a / z);
                    c := c + e;
                    z := z + 1.0;
                ];
                
                result := c * y + s;
            ];
        ]
        else
        [
            result := s;
        ];
    
    ];
    
    N(result);
];





Retract("ConfidenceIntervalOfTheMean",*);

ConfidenceIntervalOfTheMean(sampleMean,standardDeviation,standardDeviationIsKnown,sampleSize,confidenceLevel) :=
[
    Check(IsBoolean(standardDeviationIsKnown),"The third argument must be True or False.");
    
    Local(criticalZScore,criticalTScore,standardErrorOfTheMean,upperLimitValue,lowerLimitValue,resultList);
    
    resultList := {};
    
    If(sampleSize >= 30 Or standardDeviationIsKnown = True,
    [
        criticalZScore := N(ConfidenceLevelToZScore(confidenceLevel));
        
        resultList["criticalZScore"] := criticalZScore;

        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));
        
        lowerLimitValue := N(sampleMean - criticalZScore * standardErrorOfTheMean);
        
        upperLimitValue := N(sampleMean + criticalZScore * standardErrorOfTheMean);

        
        If(InVerboseMode(),
            [
                Echo("Using the normal distribution.");
                
                Echo("Critical z-score: ", criticalZScore);
                
                Echo("Standard error of the mean: ", standardErrorOfTheMean);
            ]);
    ],
    [   
        criticalTScore := OneTailAlphaToTScore(sampleSize - 1, N((1 - confidenceLevel)/2));
        
        resultList["criticalTScore"] := criticalTScore;
        
        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));
        
        lowerLimitValue := N(sampleMean - criticalTScore * standardErrorOfTheMean);
        
        upperLimitValue := N(sampleMean + criticalTScore * standardErrorOfTheMean);
        
        
        If(InVerboseMode(),
            [
                Echo("Using the t-distribution.");
                
                Echo("Critical t-score: ", criticalTScore);
                
                Echo("Standard error of the mean: ", standardErrorOfTheMean);
            ]);
    
    ]);
    
    resultList["upperLimit"] := upperLimitValue;
    
    resultList["lowerLimit"] := lowerLimitValue;

    resultList;
];



Retract("ConfidenceIntervalOfTheProportion",*);

ConfidenceIntervalOfTheProportion(numberOfSuccesses,sampleSize,confidenceLevel) :=
[
    Check(IsInteger(numberOfSuccesses) And numberOfSuccesses >= 0, "The first argument must be an integer which is >=0");
    
    Check(IsInteger(sampleSize) And sampleSize >= 0, "The second argument must be an integer which is >=0");
    
    Local(criticalZScore,approximateStandardErrorOfTheProportion,upperLimit,lowerLimit,resultList,proportion);
    
    resultList := {};
    
    criticalZScore := ConfidenceLevelToZScore(confidenceLevel);
    
    resultList["criticalZScore"] := criticalZScore;
    
    proportion := N(numberOfSuccesses/sampleSize);
    
    approximateStandardErrorOfTheProportion := Sqrt((proportion*(1 - proportion))/sampleSize);
    
    upperLimit := N(proportion + criticalZScore * approximateStandardErrorOfTheProportion);
    
    lowerLimit := N(proportion - criticalZScore * approximateStandardErrorOfTheProportion);
    
    If(InVerboseMode(),
        [
            Echo("Critical z-score: ", criticalZScore);
            
            Echo("Proportion: ", proportion);
            
            Echo("Standard error of the proportion: ", N(approximateStandardErrorOfTheProportion));
        ]);
    
    resultList["upperLimit"] := upperLimit;
    
    resultList["lowerLimit"] := lowerLimit;
    
    resultList;
];




Retract("ConfidenceLevelToZScore",*);

ConfidenceLevelToZScore(probability) :=
[
    
    probability := probability + (1 - probability)/2;
    
    ProbabilityToZScore(probability);
];





Retract("ErrorFunction",*);

ErrorFunction(x) :=
[
    Local(a1,a2,a3,a4,a5,p,sign,t,y);
    
    a1 :=  0.254829592;
    a2 := -0.284496736;
    a3 :=  1.421413741;
    a4 := -1.453152027;
    a5 :=  1.061405429;
    p  :=  0.3275911;

    
    sign := 1;
    
    If(x < 0, sign := -1);
    
    x := AbsN(x);

    
    t := 1.0/(1.0 + p*x);
    y := N(1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Exp(-x*x));

    sign*y;
];




Retract("IsSubset",*);

IsSubset(bigList, littleList) :=
[
    Local(result);
    result := True;
    
    ForEach(element, littleList)
    [
        If(Not Contains(bigList,element), result := False);
    ];

    result;
];


Mode(list) :=
[
    Check(IsList(list), "Argument must be a list.");
    
    Local(mostFrequent, highestFrequency, currentElementCount);
    
    highestFrequency := 0;
    
    noDuplicatesList := RemoveDuplicates(list);
    
    ForEach(element, noDuplicatesList)
    [
        If( (currentElementCount := Count(list, element)) > highestFrequency,[ mostFrequent := element; highestFrequency := currentElementCount;] );
    ];
    
    mostFrequent;

];


Retract("Permutations", *);

Permutations(n) :=
[
    Check(IsInteger(n), "Argument must be an integer");    

    n!;
];


Permutations(n, r) :=
[
    Check(IsInteger(n), "Argument 1 must be an integer"); 
    
    Check(IsInteger(r), "Argument 2 must be an integer"); 
    
    n! /(n-r)!;
];







Retract("ProbabilityToZScore",*);

ProbabilityToZScore(probability) :=
[
    Local(ZMAX,ZEPSILON,minimumZ,maximumZ,zValue,probabilityValue);
    
    probability := N(probability);
    
    Check(probability >= 0.0 And probability <= 1.0, "The argument must be between 0 and 1.");
    
    ZMAX := 6; 
    
    ZEPSILON := 0.000001; 
    
    minimumZ := -ZMAX;
    
    maximumZ := ZMAX;
    
    zValue := 0.0;

    While ((maximumZ - minimumZ) > ZEPSILON) 
    [
        probabilityValue := ZScoreToProbability(zValue);
        
        if (probabilityValue > probability) 
        [
            maximumZ := zValue;
        ] 
        else 
        [
            minimumZ := zValue;
        ];
        
        zValue := (maximumZ + minimumZ) * 0.5;
    ];
    
    zValue;
];



Retract("Quartile",*);

Quartile(list) :=
[
    sortedList := HeapSort(list,"<");
    
    secondQuartile := Median(sortedList);
    
    If(IsOdd(Length(sortedList)),
    [   
        secondQuartileIndex := Find(sortedList, secondQuartile);
        
        leftList := Take(sortedList, secondQuartileIndex-1);
        rightList := Take(sortedList, -(Length(sortedList) - (secondQuartileIndex) ) );
    ],
    [

        leftList := Take(sortedList, Length(sortedList)/2);
        rightList := Take(sortedList, -Length(sortedList)/2);
    ]
    );
    
    firstQuartile := Median(leftList);
    
    thirdQuartile := Median(rightList);
    
    interquartileRange := thirdQuartile - firstQuartile;
    
    {firstQuartile, secondQuartile, thirdQuartile, interquartileRange};

];


Retract("RandomPick",*);


RandomPick(list) :=
[
    Check(IsList(list), "Argument must be a list.");
    
    Check(Length(list) > 0, "The number of elements in the list must be greater than 0.");
    
    Local(pickPosition);
    
    pickPosition := RandomInteger(Length(list));

    list[pickPosition];
];


Retract("RandomPickVector", *);

RandomPickVector(list, count) :=
[
    Check(IsList(list), "Argument 1 must be a list.");
    
    Check(IsInteger(count), "Argument 2 must be an integer.");
    
    Table(RandomPick(list),x,1,count,1);
];


Retract("RandomPickWeighted",*);

RandomPickWeighted(list) :=
[

    Check(IsList(list), "Argument must be a list.");
    
    Local(element, probabilities, items, lastWeight, randomNumber, result);
    
    probabilities := 0;
    
    items := {};
    
    lastWeight := 0;
    
    
    
    
    ForEach(element,list)
    [        
        probability := element[2];

        probabilities := probabilities + probability;
    ];
    
    Check(probabilities = 1, "The probabilities must sum to 1.");
    
    
    
    
    ForEach(element,list)
    [
        probability := element[2];
        
        item := element[1];
        
        items := Append(items, {item, {lastWeight, lastWeight := lastWeight + N(probability)}} );
    ];
    
    
    
    
    randomNumber := Random();
    
    ForEach(itemData,items)
    [
        If(randomNumber >= itemData[2][1] And randomNumber <= itemData[2][2], result := itemData[1] );
    ];
    
    
    
    result;

];




Retract("Repeat",*);



LocalSymbols(count, iterations, body)[


Rulebase("Repeat",{iterations,body});



Rule("Repeat",2,10,IsInteger(iterations) And iterations > 0)
[
    Local(count);

    count := 0;

    While (iterations > 0)
    [
        Eval(body);
        iterations--;
        count++;
    ];

    count;

];





Rulebase("Repeat",{body});


Rule("Repeat",1,20,True)
[
    Local(count);

    count := 0;
    While (True)
    [
        Eval(body);
        count++;
    ];

    count;
];

];

UnFence("Repeat",2);
HoldArgumentNumber("Repeat",2,2);
UnFence("Repeat",1);
HoldArgumentNumber("Repeat",1,1);




Retract("Sample",*);

Sample(list, sampleSize) :=
[
    Check(IsList(list), "The first argument must be a list.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "The second argument must be an integer which is greater than 0.");
    
    list := Shuffle(list);

    Take(list, sampleSize);
];


Retract("SampleSizeForTheMean",*);

SampleSizeForTheMean(standardDeviation,confidenceLevel,marginOfError) :=
[
    Local(minimumSampleSize);
    
    zScore := ConfidenceLevelToZScore(confidenceLevel);
    
    minimumSampleSize := N(((zScore*standardDeviation)/marginOfError)^2);
];



Retract("SampleSizeForTheProportion",*);

SampleSizeForTheProportion(probabilityOfSuccess,confidenceLevel,marginOfError) :=
[
    Check(probabilityOfSuccess >=0 And probabilityOfSuccess <= 1, "The first argument must be between 0 and 1.");

    Local(minimumSampleSize,zScore);
    
    zScore := ConfidenceLevelToZScore(confidenceLevel);
    
    minimumSampleSize := N(probabilityOfSuccess*(1 - probabilityOfSuccess)*(zScore/marginOfError)^2);
];



ScheffeTest(levelsList, alpha) :=
[
    Check(IsListOfLists(levelsList), "The first argument must be a list of lists.");
    
    Check(alpha >= 0 And alpha <= 1, "The second argument must be a number between 0 and 1.");
    
    Local(  result,
            topOfSummary,
            pairsList,
            xBarB,
            xBarA,
            summaryTableRow,
            ssw,
            nA,
            scheffeStatisticCalculated,
            nB,
            summaryList,
            topOfPage,
            htmlJavaString,
            summaryTableRows,
            meansList,
            index,b,
            pairList,
            a,
            bottomOfPage,
            k,
            countsList,
            oneComparisonList,
            scheffeStatistic,
            bottomOfSummary,
            resultList);
    
    anova := AnovaSingleFactor(levelsList, alpha);
    
    k := Length(levelsList);
    
    scheffeStatisticCalculated := (k-1)*anova["criticalFScore"];
    
    resultList := {};
    
    resultList["scheffeStatisticCalculated"] := scheffeStatisticCalculated;
    
    meansList := {};
    
    countsList := {};
    
    ForEach(levelList,levelsList)
    [
        meansList := meansList : N(Mean(levelList));
    
        countsList := countsList : Length(levelList);
    ];
    
    pairsList := CombinationsList(1 .. Length(levelsList),2);
    
    summaryList := {};
    
    index := 1;
    
    ForEach(pairList, pairsList)
    [   
        a := pairList[1];
        
        b := pairList[2];
        
        xBarA := meansList[a];
        
        nA := countsList[a];
        
        xBarB := meansList[b];
        
        nB := countsList[b];
        
        ssw := anova["sumOfSquaresWithin"];
        
        scheffeStatistic := ScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList);
        
        oneComparisonList := {};
        
        oneComparisonList["conclusion"] := If(scheffeStatistic <= scheffeStatisticCalculated, "No Difference", "Difference");
        
        oneComparisonList["scheffeStatistic"] := scheffeStatistic;
        
        oneComparisonList["pair"] := pairList;
        
        summaryList["pair" : ToString(index)] := oneComparisonList;
        
        index++;
    ];
    
    resultList["summary"] := summaryList;
    
    
    
    
    topOfPage :=
"
    <html>
        <title>
            Scheffe Test Summary
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Scheffe Test Summary</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Sample Pair</TH> <TH> Measured Scheffe Statistic </TH> <TH> Calculated Scheffe Statistic </TH> <TH> Conclusion </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD align=\"center\"> <?Write(ToAtom(ToString(pairList[1]) : \" and \" : ToString(pairList[2])));?> </TD> <TD align=\"right\"> <?Write(summary[\"scheffeStatistic\"]);?> </TD> <TD align=\"right\"> <?Write(resultList[\"scheffeStatisticCalculated\"]);?> </TD>  <TD> <?Write(ToAtom(summary[\"conclusion\"]));?> </TD> </TR>":Nl();
    

    
    ForEach(summary, Reverse(resultList["summary"]))
    [
        summary := summary[2];

        pairList := summary["pair"];
        
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    
    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                bottomOfPage);    
    
    
    
    
    resultList["html"] := htmlJavaString;
    
    
    DestructiveReverse(resultList);

];






ScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList) :=
[
    N(((xBarA-xBarB)^2)/((ssw/Sum(i,1,k,(countsList[i] - 1))*(1/nA + 1/nB))));   
];


Retract("Shuffle",*);


Shuffle(list) :=
[
    Check(IsList(list), "Argument must be a list.");
    
    Local(index, randomIndex, temporary);
    
    list := FlatCopy(list);
    
    index := Length(list);
    
    While(index > 1)
    [
        randomIndex := RandomInteger(1,index);
        
        temporary := list[randomIndex];
        
        list[randomIndex] := list[index];
        
        list[index] := temporary;
        
        index--;
    ];      
    
    list;
];


Retract("ShuffledDeckNoSuits",*);


ShuffledDeckNoSuits() := 
[
   Shuffle(Concat(1 .. 13, 1 .. 13, 1 .. 13, 1 .. 13));
];


Retract("StandardErrorOfTheMean",*);

StandardErrorOfTheMean(sigma, sampleSize) :=
[
    Check(sigma > 0, "The first argument must be a number which is greater than 0.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "The second argument must be an integer which is greater than 0.");
    
    sigma/Sqrt(sampleSize);
];


Retract("StandardErrorOfTheProportion",*);

StandardErrorOfTheProportion(meanOfSampleProportions, sampleSize) :=
[
    Check(IsRationalOrNumber(meanOfSampleProportions), "The first argument must be a number.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "The second argument must be an integer which is greater than 0.");
    
    Sqrt((meanOfSampleProportions*(1 - meanOfSampleProportions))/sampleSize);
];




trunc(x):= [

  If(x < 0, s := -1, s := 1);
s* Floor(Abs(x));
];




intlabels(y1,y2,tnumint) := [
    diff :=y2-y1;
    x := intervals(diff,tnumint);
    bot := trunc(y1/x)*x;
  yy = bot;
  L = [];
  
  xx = 0;
  breakLoop := False;
  While (yy-x < y2 Or breakLoop = True) [
      L := Append(L, yy);
    yy := yy + x;
    
    xx++;
    If (xx > 100, breakLoop := True);
  ];
  L[i] = yy;
	L;
];




intervals(diff, NumCats) := [
    t4 := trunc(N(Ln(diff))) * 0.4342945;
  t4 = Power(10,t4);
  T := [];
  T := N(t4/10 : t4/5 : t4/2 : t4 : T);

  
  A := [];
  
  For (i := 0,i < 4, i++) [
      A := Append(A,trunc(diff/T[i]) +1);
  ];
  
  D := AbsN(10 - A[0]);
  
  index := 1;
  For (i := 1, i < 4, i++) 
  [
    if (A[i] <= 25) [
      if (A[i] > 2) [
      XX := AbsN(NumCats - A[i]);
	if (XX < D) [
        D := XX;
	  index = i+1;
	];
      ];
    ];
  ];
  T[index-1];
];





stemandleaf(x) :=
[
  Echo("Stem and Leaf Display");
  didzero := False;
   N := x.length;
  
  if (N<20)
    [
      tNumInt := 5;
    ] 
  else 
    [
      if (N < 100) 
	[
	  tNumInt := 10;
	] 
      else 
	[
	  if (N < 150) 
	    [
	      tNumInt := 15;
	    ] 
	  else
	    [
	      tNumInt := 20;
	    ];
	];
    ];
   theMax := x[N-1];
   theMin := x[0];
  alldone := False;
  if (theMax - theMin < 10) 
  [
     ratio := 1000/(theMax - theMin);
    ratio := Math.max(ratio,1000);
    ratio := trunc(Math.log(ratio) * 0.4342945);
    ratio := Math.pow(10,ratio);
    For ( i := 0, i < N , i++) 
      [
            x[i] := x[i] * ratio;
      ];
  ]
  else 
    [
      	ratio := 1;
    ];
   zcount := 0; 	
  theMin := x[0];
   abMin := Math.abs(theMin);
  theMax := x[N-1];
   Y := intervals(theMax-theMin,tNumInt);
   indexA := index +0;
  if (indexA= 2) 
    [
      Y := Y * 5;
       ncats :=5 ;
       newz := 1;
    ] 
  else 
    [
      if(indexA=3) 
	[
	  Y := Y * 2;
	   ncats := 2;
	] 
      else 
	[
	   ncats := 1;
	   newz := 0; 
	];
    ];

   cutoffs := intlabels(x[0], x[N-1], tNumInt);
  theMax := ratio * Round(theMax);
   nc := cutoffs.length;
   xx8:=0;
  While (cutoffs[nc-2] > theMax) 
    [
      nc--;
    ];
  theMax := cutoffs[nc-2];
  if (Y > AbsN(theMax)) 
    [
      nc++;
      While(Y > AbsN(theMax)) 
	[
	  xx8++;
	  if(xx8>100)[break;];
	  if (nc > Length(cutoffs)) 
	    [
	       temp := cutoffs[nc-2] - cutoffs[nc - 3];
	      temp := temp + cutoffs[nc-2];
	      cutoffs[nc-1] := temp;
	    ];
	  theMax := cutoffs[nc-1];
	  nc++;
	];
    ];
   base := trunc(theMax/Y);
   leftover := Round(theMax - base * Y);
  While (AbsN(leftover) > 10) 
    [
      leftover := AbsN(Round(leftover/10));
    ];
   theMax2 := Maximum(theMax,abMin);
   t4 := trunc(theMax2/base);
  t4 := trunc(N(Ln(t4) * .4342945));
  t4 := Power(10,t4);
   t3 := t4/10;
  if (indexA = 2) 
    [
      if (leftover >= 8)
	[
	   newz := 1;
	]
    else 
      [
	if (leftover >= 6)  
	  [
	     newz := 0;
	  ]
	else 
	  [
	    if (leftover >= 4) 
	      [
		 newz := 4;
	      ] 
	    else 
	      [
		if (leftover >= 2) 
		  [
		     newz := 3;
		  ] 
		else 
		  [
		     newz := 2; 
		  ];
	      ];
	  ];
      ];
    ]
  else 
    [
    if (indexA = 3) 
      [
	if (leftover >=5) 
	  [
	     newz := 1;
	  ] 
	else 
	  [
	     newz := 0;
	  ];
      ];
    ];
   start := False;
   LN := 1;
   LN2 := 0;
   nn := N;
   cur := cutoffs[nc-2];
   count := nc-2;
   base2 :=base;
   newline := True;
   stems := {base2};
   leaves := {""};

 
  For ( i := nn-1, i >= 0 , i--) 
    [
     it := x[i];
     dd := Round(it/t3) * t3;
     b := trunc(dd/t4);
     L := dd-t4*b;
    leftover := AbsN(Round(L/t3));
    While (leftover >= 10)
      [
	    leftover := Round(leftover/10);
      ];
    if (it >=0) 
      [
	     tt := t3;
      ]
    else 
      [
        tt := -t3;
      ];
      
     xz := b * t4 + leftover * tt;
     
    if (it<0)
      [
	    if (xz > 0 ) 
          [
            xz := xz * -1;
          ];
          xz := xz - .00001;
      ];
      
    if (xz<cur) 
    [
	    newline := True;
        While (xz<cur)
         [
	          LN ++;
              if (start) 
              [
	              LN2++;
                  leaves  := Append(leaves, "");
              ];
              temp := trunc(LN/ncats);
              temp := LN - temp*ncats;
              
              if(temp = newz)
              [
                if (base2 = 0) 
                [
                    if (didzero)
                    [
                base2 := base2 - 1;
                    ] 
                    else 
                    [
                        didzero := 1;
                    ];
               ]
               else 
                [
            base2 := base2 - 1;
                ];
          ];
	
          count := count - 1;
          
          if (count < 0)
          [
            cur := xz -1000;
          ] 
          else 
          [
            cur := cutoffs[count];
          ];
          
          if (base2 = 0)
          [
	            zcount ++;
                if ( ((indexA = 2) And (zcount >=6)) Or ((indexA = 3) And (zcount >=3)) Or ((indexA = 1) And (zcount >1)) Or ((indexA = 4) And (zcount >1))) 
                 [
                    stems := Append(stems,"-" : ToString(base2));
                 ] 
                 else 
                 [
                        stems := Append(stems, ToString(base2));
                 ];
          ] 
          else 
          [
	            stems := Append(stems, ToString(base2));
          ];
	
	   ];
      
      
      ];
      
    start := True;
    leftover := ToString(leftover);
    
    if (it>=0) 
      [
     
  leaves[LN2] := leftover : "" : leaves[LN2];
     
      ]
    else 
      [
            leaves[LN2] := leaves[LN2] : "" : leftover;
      ];
    ];
  
  For ( i := 0, i < N , i++) [
    x[i] := x[i] / ratio;
  ];
  

  Echo("Stems Leaves");
    For (i:=0, i<leaves.length, i++)[
        test := " " : stems[i];
    
      While (test.length < 8) 
       [
            test := " " : test;
       ];
       test := test : "|";
       Echo(test :  leaves[i]);
      
    ];
  

  
];

	
	

Retract("ValueToZScore",*);

ValueToZScore(value,mean,standardDeviation) :=
[
    (value - mean)/standardDeviation;
];



WeightedMean(list) :=
[

    Check(IsList(list), "Argument must be a list.");
    
    Local( values, lastWeight, weights );
    
    values := {};
    
    weights := {};
    
    
    ForEach(element,list)
    [        
        Check(IsList(element), "Values and their associated weights must be in a list.");
        
        Check(Length(element) = 2, "Each value and its associated weight must be in a two element list.");
        
        values := values : element[1];

        weights := weights : element[2];
    ];
    
    Sum(values * weights)/Sum(weights);

];








ZScoreToProbability(zScore) :=
[
    zScore := N(zScore);
    
    Local( y, x, w, ZMAX, result);
    
    ZMAX := 6; 
    
    if(zScore = 0.0)
    [
        x := 0.0;
    ]
    else
    [
        y := 0.5 * AbsN(zScore);
        
        if(y > ZMAX * 0.5)
        [
            x := 1.0;
        ]
        else if(y < 1.0)
        [
            w := y * y;
            x := ((((((((0.000124818987 * w
            - 0.001075204047) * w + 0.005198775019) * w
            - 0.019198292004) * w + 0.059054035642) * w
            - 0.151968751364) * w + 0.319152932694) * w
            - 0.531923007300) * w + 0.797884560593) * y * 2.0;
        ]
        else
        [
            y := y - 2.0;
            
            x := (((((((((((((-0.000045255659 * y
            + 0.000152529290) * y - 0.000019538132) * y
            - 0.000676904986) * y + 0.001390604284) * y
            - 0.000794620820) * y - 0.002034254874) * y
            + 0.006549791214) * y - 0.010557625006) * y
            + 0.011630447319) * y - 0.009279453341) * y
            + 0.005353579108) * y - 0.002141268741) * y
            + 0.000535310849) * y + 0.999936657524;
        ];
    ];
    
        
    If(zScore > 0.0 , result := (x + 1.0) * 0.5 , result := (1.0 - x) * 0.5);
    
    result;
];



Retract("ZScoreToValue",*);

ZScoreToValue(zScore,mean,standardDeviation) :=
[
    -((-mean)/standardDeviation - zScore)*standardDeviation;
];


