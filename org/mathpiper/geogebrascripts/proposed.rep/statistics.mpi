







AlphaToChiSquareScore(p, df) :=
[
    Local(ChiEpsilon, ChiMax, minchisq, maxchisq, chisqval, result);
    
    ChiEpsilon := 0.000001;   
    
    ChiMax := 99999.0;        
    
    minchisq := 0.0;
    
    maxchisq := ChiMax;
    
    p := N(p);
    
    if( p <= 0.0 Or p >= 1.0)
    [
    
        if (p <= 0.0) 
        [
            result := maxchisq;
        ] 
        else 
        [
            if (p >= 1.0) 
            [
                result := 0.0;
            ];
        ];
    
    ]
    else
    [
        chisqval := N(df / SqrtN(p));
        
        
        While ((maxchisq - minchisq) > ChiEpsilon) 
        [
            if (ChiSquareScoreToAlpha(chisqval, df) < p) 
            [
                maxchisq := chisqval;
            ] 
            else 
            [
                minchisq := chisqval;
            ];
            chisqval := (maxchisq + minchisq) * 0.5;
        ];
        
        result := chisqval;
    
    ];
    
    N(result);
];




AnovaCompletelyRandomizedBlock(levelsList, alpha) :=
[
    Check(IsMatrix(levelsList), "Argument", "The first argument must be a list of equal-length lists.");
    
    Check(alpha >= 0 And alpha <= 1, "Argument", "The second argument must be a number between 0 and 1.");
    
    Local(
        topOfSummary,
        anovaBlockTableRow1,
        criticalFScore,
        anovaBlockTableRow3,
        anovaBlockTableRow2,
        lengthsList,
        summaryTableRow,
        sumsList,
        meanSquareWithin,
        topOfPage,
        htmlJavaString,
        index,
        variancesList,
        grandMean,
        row,
        topOfAnovaBlock,
        result,
        fScoreBlock,
        criticalFScoreBlock,
        blockMeansList,
        sumOfSquaresWithin',
        meanSquareBetween,
        sumOfSquaresBetween,
        fScore,
        summaryTableRows,
        meansList,
        sumOfSquaresBlock,
        b,
        blockSummaryTableRow,
        bottomOfAnovaBlock,
        sumOfSquaresWithin,
        bottomOfPage,
        k,
        sumOfSquaresTotal,
        meanSquareBlock,
        bottomOfSummary
    );
    
    meansList := {};
    
    variancesList := {};
    
    sumsList := {};
    
    lengthsList := {};
    
    
    
    ForEach(levelList, levelsList)
    [
        meansList := meansList : N(Mean(levelList));
        
        variancesList := variancesList : N(UnbiasedVariance(levelList));
        
        sumsList := sumsList : N(Sum(levelList));

        lengthsList := lengthsList : Length(levelList);
    ];
    
    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);

    grandMean := N(Mean(meansList));
    
    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);
    
    
    
    
    blockMeansList := {};
    
    index := 1;
    
    While(index <= Length(First(levelsList)) )
    [
        row := MatrixColumn(levelsList, index);
        
        blockMeansList := Append(blockMeansList,N(Mean(row)));
    
        index++;
    ];
    
    b := Length(blockMeansList);
    
    k := Length(levelsList);
    
    sumOfSquaresBlock := Sum(j,1,b, k*(blockMeansList[j] - grandMean)^2);
    
    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);
    
    sumOfSquaresWithin' := N(sumOfSquaresTotal - sumOfSquaresBetween - sumOfSquaresBlock);
    
    meanSquareBetween := N(sumOfSquaresBetween/(k - 1));
    
    meanSquareWithin := N(sumOfSquaresWithin'/((k - 1)*(b - 1)));
    
    fScore := N(meanSquareBetween/meanSquareWithin);
    
    meanSquareBlock := N(sumOfSquaresBlock/(b - 1));
    
    fScoreBlock := N(meanSquareBlock/meanSquareWithin);
    
    criticalFScore := ProbabilityToFScore(k - 1, (k - 1)*(b - 1), 1-alpha);
    
    criticalFScoreBlock := ProbabilityToFScore(b - 1, (k - 1)*(b - 1), 1-alpha);
    
    
    
    topOfPage :=
"
    <html>
        <title>
            Anova: Completely Randomized Block
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Anova: Completely Randomized Block</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD> <?Write(ToAtom(ToString(Level):ToString(index)));?> </TD> <TD align=\"right\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>":Nl();
    
    
    
    index := 1;
    
    While(index <= Length(levelsList))
    [
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    

    
    
    blockSummaryTableRow := "<TR> <TD> <?Write(ToAtom(\"Block\":ToString(index)));?> </TD> <TD align=\"right\"> <?Write(Length(row));?> </TD> <TD> <?Write(N(Sum(row)));?> </TD>  <TD> <?Write(N(Mean(row)));?> </TD> <TD> <?Write(N(UnbiasedVariance(row)));?> </TD> </TR>":Nl();

    index := 1;
    
    While(index <= Length(First(levelsList)) )
    [
        row := MatrixColumn(levelsList, index);
        
        summaryTableRows := summaryTableRows : PatchString(blockSummaryTableRow);
    
        index++;
    ];
    
    
    
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    


    topOfAnovaBlock :=
"
            <br \>
            <br \>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>ANOVA: Completely Randomized Block</h3>  </CAPTION>
                
                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square </TH> <TH> F </TH> <TH> F Critical </TH> </TR>
";

    
    
    anovaBlockTableRow1 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Levels\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(k - 1);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>":Nl());
    
    anovaBlockTableRow2 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Blocks\"));?> </TD> <TD > <?Write(sumOfSquaresBlock);?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareBlock);?> </TD> <TD> <?Write(fScoreBlock);?> </TD> <TD> <?Write(criticalFScoreBlock);?> </TD> </TR>":Nl());

    anovaBlockTableRow3 := PatchString("<TR> <TD> <?Write(ToAtom(\"Within Levels\"));?> </TD> <TD > <?Write(sumOfSquaresWithin');?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>":Nl());

    bottomOfAnovaBlock :=
"
            </TABLE>
";


    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                topOfAnovaBlock : 
                anovaBlockTableRow1 : 
                anovaBlockTableRow2 : 
                anovaBlockTableRow3 : 
                bottomOfAnovaBlock :
                bottomOfPage);
                
                
                
     result := {};
     
     result["html"] := htmlJavaString;
     
     result["sumOfSquaresWithin'"] := sumOfSquaresWithin';
     
     result["sumOfSquaresBetween"] := sumOfSquaresBetween;
     
     result["sumOfSquaresBlock"] := sumOfSquaresBlock;
     
     result["sumOfSquaresTotal"] := sumOfSquaresTotal;
     
     result["meanSquareBetween"] := meanSquareBetween;
     
     result["meanSquareWithin"] := meanSquareWithin;
     
     result["meanSquareBlock"] := meanSquareBlock;
     
     result["fScore"] := fScore;
     
     result["criticalFScore"] := criticalFScore;
     
     result["fScoreBlock"] := fScoreBlock;
     
     result["criticalFScoreBlock"] := criticalFScoreBlock;
     
     result;
];



Retract("AnovaSingleFactor",*);

AnovaSingleFactor(levelsList, alpha) :=
[
    Check(IsListOfLists(levelsList), "Argument", "The first argument must be a list of lists.");
    
    Check(alpha >= 0 And alpha <= 1, "Argument", "The second argument must be a number between 0 and 1.");
    
    Local(
        anovaTableRow1,
        anovaTableRow2,
        anovaTableRow3,
        anovaTableTotal,
        bottomOfAnova,
        bottomOfPage,
        bottomOfSummary,
        criticalFScore,
        degreesOfFreedomBetween,
        degreesOfFreedomWithin,
        fScore,
        grandMean,
        htmlJavaString,
        index,
        lengthsList,
        meansList,
        meanSquareBetween,
        meanSquareWithin,
        result,
        summaryTableRow,
        summaryTableRows,
        sumOfSquaresBetween,
        sumOfSquaresTotal,
        sumOfSquaresWithin,
        sumsList,
        topOfAnova,
        topOfPage,
        topOfSummary,
        variancesList);

    meansList := {};
    
    variancesList := {};
    
    sumsList := {};
    
    lengthsList := {};
    
    ForEach(levelList, levelsList)
    [
        meansList := meansList : N(Mean(levelList));
        
        variancesList := variancesList : N(UnbiasedVariance(levelList));
        
        sumsList := sumsList : N(Sum(levelList));

        lengthsList := lengthsList : Length(levelList);
    ];
    
    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);

    grandMean := N(Mean(Flatten(levelsList, "List")));
    
    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);
    
    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);
    
    degreesOfFreedomBetween := (Length(levelsList)-1);
    
    degreesOfFreedomWithin := (ElementCount(levelsList) - Length(levelsList));
    
    meanSquareBetween := N(sumOfSquaresBetween/degreesOfFreedomBetween);
    
    meanSquareWithin := N(sumOfSquaresWithin/degreesOfFreedomWithin);
    
    fScore := N(meanSquareBetween/meanSquareWithin);
    
    criticalFScore := ProbabilityToFScore(degreesOfFreedomBetween, degreesOfFreedomWithin, 1-alpha);
    
    topOfPage :=
"
    <html>
        <title>
            Anova: Single Factor
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Anova: Single Factor</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD> <?Write(ToAtom(\"Level\":ToString(index)));?> </TD> <TD align=\"right\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>":Nl();
    
    index := 1;
    While(index <= Length(levelsList))
    [
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    


    topOfAnova :=
"
            <br \>
            <br \>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>ANOVA</h3>  </CAPTION>
                
                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square Between </TH> <TH> F </TH> <TH> F Critical </TH> </TR>
";

    
    
    anovaTableRow1 := PatchString("<TR> <TD> <?Write(ToAtom(\"Between Levels\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(degreesOfFreedomBetween);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>":Nl());
    
    anovaTableRow2 := PatchString("<TR> <TD> <?Write(ToAtom(\"Within Levels\"));?> </TD> <TD > <?Write(sumOfSquaresWithin);?> </TD> <TD> <?Write(degreesOfFreedomWithin);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>":Nl());
    
    anovaTableTotal := PatchString("<TR> <TD> Total </TD> <TD> <?Write(sumOfSquaresTotal);?> </TD> <TD> <?Write(degreesOfFreedomBetween + degreesOfFreedomWithin);?> </TD> </TR>");
    
    bottomOfAnova :=
"
            </TABLE>
";


    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                topOfAnova : 
                anovaTableRow1 : 
                anovaTableRow2 : 
                anovaTableTotal : 
                bottomOfAnova : 
                bottomOfPage);
                
                
                
     result := {};
     
     result["html"] := htmlJavaString;
     
     result["sumOfSquaresWithin"] := sumOfSquaresWithin;
     
     result["sumOfSquaresBetween"] := sumOfSquaresBetween;
     
     result["sumOfSquaresTotal"] := sumOfSquaresTotal;
     
     result["degreesOfFreedomBetween"] := degreesOfFreedomBetween;
     
     result["degreesOfFreedomWithin"] := degreesOfFreedomWithin;
     
     result["meanSquareBetween"] := meanSquareBetween;
     
     result["meanSquareWithin"] := meanSquareWithin;
     
     result["fScore"] := fScore;
     
     result["criticalFScore"] := criticalFScore;
     
     result;
];



Retract("BinomialDistributionMean", *);

BinomialDistributionMean(probability,numberOfTrials) :=
[

    Check(IsRationalOrNumber(probability) And p >= 0 And p <= 1, "Argument", "The first argument must be a number between 0 and 1.");
    
    Check(IsInteger(numberOfTrials) And numberOfTrials >= 0, "Argument", "The second argument must be an integer which is greater than 0.");
    
    numberOfTrials * probability;
];
	



Retract("BinomialDistributionStandardDeviation", *);

BinomialDistributionStandardDeviation(probability,numberOfTrials) :=
[

    Check(IsRationalOrNumber(probability) And p >= 0 And p <= 1, "Argument", "The first argument must be a number between 0 and 1.");
    
    Check(IsInteger(numberOfTrials) And numberOfTrials >= 0, "Argument", "The second argument must be an integer which is greater than 0.");
    
    SqrtN(numberOfTrials * probability * (1 - probability));
];
	







ChiSquareScoreToAlpha(score, degreesOfFreedom) :=
[
    Local(a, y, s, e, c, z, LogSqrtPi, ISqrtPi,result);                     
    
    y := 0;
    
    LogSqrtPi := 0.5723649429247000870717135; 
    
    ISqrtPi := 0.5641895835477562869480795;   
    
    if(score <= 0.0 Or degreesOfFreedom < 1) 
    [
        result := 1.0;
    ]
    else
    [
        a := N(0.5 * score);
        
        if (degreesOfFreedom > 1) 
        [
            y := If(-a < -20, 0, ExpN(-a));
        ];
        
        s := If(IsEven(degreesOfFreedom), y , (2.0 * ZScoreToProbability(-SqrtN(score))));
        
        if (degreesOfFreedom > 2) 
        [
            score := 0.5 * (degreesOfFreedom - 1.0);
            
            z := If(IsEven(degreesOfFreedom), 1.0, 0.5);
            
            if (a > 20) 
            [
                e := If(IsEven(degreesOfFreedom), 0.0, LogSqrtPi);
                
                c := LogN(a);
                
                While(z <= score) 
                [
                    e := LogN(z) + e;
                    s := s + If(c * z - a - e < -20, 0, ExpN(c * z - a - e));
                    z := z + 1.0;
                ];
                result := s;
            ] 
            else 
            [
                e := If(IsEven(degreesOfFreedom) , 1.0, (ISqrtPi / SqrtN(a)));
                
                c := 0.0;
                
                While(z <= score) 
                [
                    e := e * (a / z);
                    c := c + e;
                    z := z + 1.0;
                ];
                
                result := c * y + s;
            ];
        ]
        else
        [
            result := s;
        ];
    
    ];
    
    N(result);
];





CoefficientOfDetermination(x,y) :=
[   
    Check(IsList(x), "Argument", "The first argument must be a list.");
    
    Check(IsList(y), "Argument", "The second argument must be a list.");
    
    Check(Length(x) = Length(y), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    N(CorrelationCoefficient(x,y)^2);
];


Retract("ConfidenceIntervalOfTheMean",*);

ConfidenceIntervalOfTheMean(sampleMean,standardDeviation,standardDeviationIsKnown,sampleSize,confidenceLevel) :=
[
    Check(IsBoolean(standardDeviationIsKnown), "Argument", "The third argument must be True or False.");
    
    Local(criticalZScore,criticalTScore,standardErrorOfTheMean,upperLimitValue,lowerLimitValue,resultList);
    
    resultList := {};
    
    If(sampleSize >= 30 Or standardDeviationIsKnown = True,
    [
        criticalZScore := N(ConfidenceLevelToZScore(confidenceLevel));
        
        resultList["criticalZScore"] := criticalZScore;

        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));
        
        lowerLimitValue := N(sampleMean - criticalZScore * standardErrorOfTheMean);
        
        upperLimitValue := N(sampleMean + criticalZScore * standardErrorOfTheMean);

        
        If(InVerboseMode(),
            [
                Echo("Using the normal distribution.");
                
                Echo("Critical z-score: ", criticalZScore);
                
                Echo("Standard error of the mean: ", standardErrorOfTheMean);
            ]);
    ],
    [   
        criticalTScore := OneTailAlphaToTScore(sampleSize - 1, N((1 - confidenceLevel)/2));
        
        resultList["criticalTScore"] := criticalTScore;
        
        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));
        
        lowerLimitValue := N(sampleMean - criticalTScore * standardErrorOfTheMean);
        
        upperLimitValue := N(sampleMean + criticalTScore * standardErrorOfTheMean);
        
        
        If(InVerboseMode(),
            [
                Echo("Using the t-distribution.");
                
                Echo("Critical t-score: ", criticalTScore);
                
                Echo("Standard error of the mean: ", standardErrorOfTheMean);
            ]);
    
    ]);
    
    resultList["upperLimit"] := upperLimitValue;
    
    resultList["lowerLimit"] := lowerLimitValue;

    resultList;
];



Retract("ConfidenceIntervalOfTheProportion",*);

ConfidenceIntervalOfTheProportion(numberOfSuccesses,sampleSize,confidenceLevel) :=
[
    Check(IsInteger(numberOfSuccesses) And numberOfSuccesses >= 0, "Argument", "The first argument must be an integer which is >=0");
    
    Check(IsInteger(sampleSize) And sampleSize >= 0, "Argument", "The second argument must be an integer which is >=0");
    
    Local(criticalZScore,approximateStandardErrorOfTheProportion,upperLimit,lowerLimit,resultList,proportion);
    
    resultList := {};
    
    criticalZScore := ConfidenceLevelToZScore(confidenceLevel);
    
    resultList["criticalZScore"] := criticalZScore;
    
    proportion := N(numberOfSuccesses/sampleSize);
    
    approximateStandardErrorOfTheProportion := Sqrt((proportion*(1 - proportion))/sampleSize);
    
    upperLimit := N(proportion + criticalZScore * approximateStandardErrorOfTheProportion);
    
    lowerLimit := N(proportion - criticalZScore * approximateStandardErrorOfTheProportion);
    
    If(InVerboseMode(),
        [
            Echo("Critical z-score: ", criticalZScore);
            
            Echo("Proportion: ", proportion);
            
            Echo("Standard error of the proportion: ", N(approximateStandardErrorOfTheProportion));
        ]);
    
    resultList["upperLimit"] := upperLimit;
    
    resultList["lowerLimit"] := lowerLimit;
    
    resultList;
];




Retract("ConfidenceLevelToZScore",*);

ConfidenceLevelToZScore(probability) :=
[
    
    probability := probability + (1 - probability)/2;
    
    ProbabilityToZScore(probability);
];



ControlChartConstants(n) :=
[   
    Check(n >= 2 And n <= 15, "Argument", "The argument n must be 2 <= n <= 20.");
    
    Local(result, table);
    
    result := {};
    
    n--;
    
    table := {
        {1.880, 1.128, 0.000, 3.267},
        {1.023, 1.693, 0.000, 2.574},
        {0.729, 2.059, 0.000, 2.282},
        {0.577, 2.326, 0.000, 2.114},
        {0.483, 2.534, 0.000, 2.004},
        {0.419, 2.704, 0.076, 1.924},
        {0.373, 2.847, 0.136, 1.864},
        {0.337, 2.970, 0.184, 1.816},
        {0.308, 3.078, 0.223, 1.777},
        {0.285, 3.173, 0.256, 1.744},
        {0.266, 3.258, 0.283, 1.717},
        {0.249, 3.336, 0.307, 1.693},
        {0.235, 3.407, 0.328, 1.672},
        {0.223, 3.472, 0.347, 1.653},
        {0.212, 3.532, 0.363, 1.637},
        {0.203, 3.588, 0.378, 1.622},
        {0.194, 3.640, 0.391, 1.608},
        {0.187, 3.689, 0.403, 1.597},
        {0.180, 3.735, 0.415, 1.585},
    };

    result["D4"] := table[n][4];
    
    result["D3"] := table[n][3];
    
    result["d2"] := table[n][2];
        
    result["A2"] := table[n][1];
    
    result;
];



CorrelationCoefficient(x,y) :=
[   
    Check(IsList(x), "Argument", "The first argument must be a list.");
    
    Check(IsList(y), "Argument", "The second argument must be a list.");
    
    Check(Length(x) = Length(y), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    Local(n);
        
    n := Length(x);
    
    N((n*Sum(x*y)-Sum(x)*Sum(y))/Sqrt((n*Sum(x^2)-(Sum(x))^2)*(n*Sum(y^2)-(Sum(y)^2))) );
];


CorrelationMatrix(dataLists) := 
[
    Local(namesList, correlationMatrix);
    
    ForEach(dataList, dataLists)
    [
        Check(IsMatrix(dataLists), "Argument", "All lists must have the same number of elements.");
    ];

    namesList := MatrixColumn(dataLists,1);
    
    namesList := "" : namesList;
    
    ForEach(dataList, dataLists)
    [
        PopFront(dataList);
    ];
    
    correlationMatrix := ZeroMatrix(Length(dataLists)+1);
    
    ForEach(rowIndex, 1 .. Length(dataLists) + 1)
    [
        ForEach(columnIndex, 1 .. Length(dataLists) + 1)
        [
            if(rowIndex >= 2 And columnIndex >= 2)
            [
                correlationMatrix[rowIndex][columnIndex] := N(CorrelationCoefficient(dataLists[rowIndex - 1],dataLists[columnIndex - 1]),2);
            ]
            else if(rowIndex = 1)
            [
                correlationMatrix[rowIndex][columnIndex] := namesList[columnIndex];
            ]
            else
            [
                correlationMatrix[rowIndex][columnIndex] := namesList[rowIndex];
            ];
        ];
    ];
    
    correlationMatrix;
];


D2Value(k,n) :=
[
    Check(k >= 0 And k <= 15, "Argument", "The first argument k must be 0 <= k <= 15.");
    
    Check(n >= 2 And n <= 15, "Argument", "The second argument n must be 2 <= n <= 15.");
    
    n--;
    
    if(k = 0)
    [
        {1.128,1.693,2.059,2.326,2.534,2.704,2.847,2.970,3.078,3.173,3.259,3.336,3.407,3.472}[n];
    ]
    else
    [
        {
            {1.414, 1.912, 2.239, 2.481, 2.673, 2.830, 2.963, 3.078, 3.179, 3.269, 3.350, 3.424, 3.491, 3.553},
            {1.279, 1.805, 2.151, 2.405, 2.604, 2.768, 2.906, 3.025, 3.129, 3.221, 3.305, 3.380, 3.449, 3.513},
            {1.231, 1.769, 2.120, 2.379, 2.581, 2.747, 2.886, 3.006, 3.112, 3.205, 3.289, 3.366, 3.435, 3.499},
            {1.206, 1.750, 2.105, 2.366, 2.570, 2.736, 2.877, 2.997, 3.103, 3.197, 3.282, 3.358, 3.428, 3.492},
            {1.191, 1.739, 2.096, 2.358, 2.563, 2.730, 2.871, 2.992, 3.098, 3.192, 3.277, 3.354, 3.424, 3.488},
            {1.181, 1.731, 2.090, 2.353, 2.558, 2.726, 2.867, 2.988, 3.095, 3.189, 3.274, 3.351, 3.421, 3.486},
            {1.173, 1.726, 2.085, 2.349, 2.555, 2.723, 2.864, 2.986, 3.092, 3.187, 3.272, 3.349, 3.419, 3.484},
            {1.168, 1.721, 2.082, 2.346, 2.552, 2.720, 2.862, 2.984, 3.090, 3.185, 3.270, 3.347, 3.417, 3.482},
            {1.164, 1.718, 2.080, 2.344, 2.550, 2.719, 2.860, 2.982, 3.089, 3.184, 3.269, 3.346, 3.416, 3.481},
            {1.160, 1.716, 2.077, 2.342, 2.549, 2.717, 2.859, 2.981, 3.088, 3.183, 3.268, 3.345, 3.415, 3.480},
            {1.157, 1.714, 2.076, 2.340, 2.547, 2.716, 2.858, 2.980, 3.087, 3.182, 3.267, 3.344, 3.415, 3.479},
            {1.155, 1.712, 2.074, 2.344, 2.546, 2.715, 2.857, 2.979, 3.086, 3.181, 3.266, 3.343, 3.414, 3.479},
            {1.153, 1.710, 2.073, 2.338, 2.545, 2.714, 2.856, 2.978, 3.085, 3.180, 3.266, 3.343, 3.413, 3.478},
            {1.151, 1.709, 2.072, 2.337, 2.545, 2.714, 2.856, 2.978, 3.085, 3.180, 3.265, 3.342, 3.413, 3.478},
            {1.150, 1.708, 2.071, 2.337, 2.544, 2.713, 2.855, 2.977, 3.084, 3.179, 3.265, 3.342, 3.412, 3.477}
        }[k][n];
    ];
    
];






Retract("ErrorFunction",*);

ErrorFunction(x) :=
[
    Local(a1,a2,a3,a4,a5,p,sign,t,y);
    
    a1 :=  0.254829592;
    a2 := -0.284496736;
    a3 :=  1.421413741;
    a4 := -1.453152027;
    a5 :=  1.061405429;
    p  :=  0.3275911;

    
    sign := 1;
    
    If(x < 0, sign := -1);
    
    x := AbsN(x);

    
    t := 1.0/(1.0 + p*x);
    y := N(1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Exp(-x*x));

    sign*y;
];




Retract("IsSubset",*);

IsSubset(bigList, littleList) :=
[
    Local(result);
    result := True;
    
    ForEach(element, littleList)
    [
        If(Not Contains(bigList,element), result := False);
    ];

    result;
];


Mode(list) :=
[
    Check(Length(list) > 0 And IsNumericList(list), "Argument", "Argument must be a nonempty numeric list.");
    
    Local(noDuplicatesList, countsList, sortedList, highestCountsList, resultList);
    
    noDuplicatesList := RemoveDuplicates(list);
    
    countsList := {};
    
    ForEach(element, noDuplicatesList)
    [
        countsList := Append(countsList, {Count(list, element), element} );
    ];
    
    sortedList := HeapSort(countsList,Lambda({x,y},x[1] > y[1]));
    
    highestCountsList := Select(sortedList, Lambda({x},x[1] = sortedList[1][1]));
    
    resultList := MapSingle(Lambda({x},x[2]), highestCountsList);

];


Retract("Permutations", *);

Permutations(n) :=
[
    Check(IsInteger(n), "Argument", "Argument must be an integer");

    n!;
];


Permutations(n, r) :=
[
    Check(IsInteger(n), "Argument", "Argument 1 must be an integer");
    
    Check(IsInteger(r), "Argument", "Argument 2 must be an integer");
    
    n! /(n-r)!;
];







Retract("ProbabilityToZScore",*);

ProbabilityToZScore(probability) :=
[
    Local(ZMAX,ZEPSILON,minimumZ,maximumZ,zValue,probabilityValue);
    
    probability := N(probability);
    
    Check(probability >= 0.0 And probability <= 1.0, "Argument", "The argument must be between 0 and 1.");
    
    ZMAX := 6; 
    
    ZEPSILON := 0.000001; 
    
    minimumZ := -ZMAX;
    
    maximumZ := ZMAX;
    
    zValue := 0.0;

    While ((maximumZ - minimumZ) > ZEPSILON) 
    [
        probabilityValue := ZScoreToProbability(zValue);
        
        if (probabilityValue > probability) 
        [
            maximumZ := zValue;
        ] 
        else 
        [
            minimumZ := zValue;
        ];
        
        zValue := (maximumZ + minimumZ) * 0.5;
    ];
    
    zValue;
];



Retract("Quartile",*);

Quartile(list) :=
[
    sortedList := HeapSort(list,"<");
    
    secondQuartile := Median(sortedList);
    
    If(IsOdd(Length(sortedList)),
    [   
        secondQuartileIndex := Find(sortedList, secondQuartile);
        
        leftList := Take(sortedList, secondQuartileIndex-1);
        rightList := Take(sortedList, -(Length(sortedList) - (secondQuartileIndex) ) );
    ],
    [

        leftList := Take(sortedList, Length(sortedList)/2);
        rightList := Take(sortedList, -Length(sortedList)/2);
    ]
    );
    
    firstQuartile := Median(leftList);
    
    thirdQuartile := Median(rightList);
    
    interquartileRange := thirdQuartile - firstQuartile;
    
    {firstQuartile, secondQuartile, thirdQuartile, interquartileRange};

];


Retract("RandomPick",*);


RandomPick(list) :=
[
    Check(IsList(list), "Argument", "Argument must be a list.");
    
    Check(Length(list) > 0, "Argument", "The number of elements in the list must be greater than 0.");
    
    Local(pickPosition);
    
    pickPosition := RandomInteger(Length(list));

    list[pickPosition];
];


Retract("RandomPickVector", *);

RandomPickVector(list, count) :=
[
    Check(IsList(list), "Argument", "Argument 1 must be a list.");
    
    Check(IsInteger(count), "Argument", "Argument 2 must be an integer.");
    
    Table(RandomPick(list),x,1,count,1);
];


Retract("RandomPickWeighted",*);

RandomPickWeighted(list) :=
[

    Check(IsList(list), "Argument", "Argument must be a list.");
    
    Local(element, probabilities, items, lastWeight, randomNumber, result);
    
    probabilities := 0;
    
    items := {};
    
    lastWeight := 0;
    
    
    
    
    ForEach(element,list)
    [        
        probability := element[2];

        probabilities := probabilities + probability;
    ];
    
    Check(probabilities = 1, "Argument", "The probabilities must sum to 1.");
    
    
    
    
    ForEach(element,list)
    [
        probability := element[2];
        
        item := element[1];
        
        items := Append(items, {item, {lastWeight, lastWeight := lastWeight + N(probability)}} );
    ];
    
    
    
    
    randomNumber := Random();
    
    ForEach(itemData,items)
    [
        If(randomNumber >= itemData[2][1] And randomNumber <= itemData[2][2], result := itemData[1] );
    ];
    
    
    
    result;

];


Range(list) :=
[
    Check(Length(list) > 0 And IsNumericList(list), "Argument", "Argument must be a nonempty numeric list.");
    
    Maximum(list) - Minimum(list);
];


RegressionLine(x,y) :=
[   
    Check(IsList(x), "Argument", "The first argument must be a list.");
    
    Check(IsList(y), "Argument", "The second argument must be a list.");
    
    Check(Length(x) = Length(y), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    Local(n,a,b,xMean,yMean,line,result);
    
    n := Length(x);
    
    b := N((n*Sum(x*y) - Sum(x)*Sum(y))/(n*Sum(x^2)-(Sum(x))^2));
    
    xMean := N(Mean(x));
    
    yMean := N(Mean(y));
    
    a := N(yMean - b*xMean);
    
    line := a + b*Hold(x);
    
    result := {};
    
    result["xMean"] := xMean;
    
    result["yMean"] := yMean;
    
    result["line"] := line;
    
    result["yIntercept"] := a;
    
    result["slope"] := b;
    
    result["count"] := n;
    
    result;
];


RegressionLineConfidenceInterval(x,y,xValue,confidenceLevel) :=
[   
    Check(IsList(x), "Argument", "The first argument must be a list.");
    
    Check(IsList(y), "Argument", "The second argument must be a list.");
    
    Check(Length(x) = Length(y), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    Check(confidenceLevel >=0 And confidenceLevel <=1, "Argument", "The confidence level must be >= 0 and <= 1.");
    
    Local(n,a,b,xMean,part,result,criticalTScore,standardErrorOfTheEstimate);
    
    regressionLine := RegressionLine(x,y);
    
    n := regressionLine["count"];
    
    f(x) := [Eval(regressionLine["line"]);];
    
    criticalTScore := OneTailAlphaToTScore(n-2, N((1 - confidenceLevel)/2));
    
    standardErrorOfTheEstimate := StandardErrorOfTheEstimate(x,y);

    xMean := regressionLine["xMean"];

    part := N(criticalTScore * standardErrorOfTheEstimate * Sqrt(1/n + ((xValue - xMean)^2)/(Sum(x^2) - Sum(x)^2/n)));
    
    result := {};
    
    result["upper"] := f(xValue) + part;
    
    result["lower"] := f(xValue) - part;
    
    result;
];




Retract("Repeat",*);



LocalSymbols(count, iterations, body)[


Rulebase("Repeat",{iterations,body});



Rule("Repeat",2,10,IsInteger(iterations) And iterations > 0)
[
    Local(count);

    count := 0;

    While (iterations > 0)
    [
        Eval(body);
        iterations--;
        count++;
    ];

    count;

];





Rulebase("Repeat",{body});


Rule("Repeat",1,20,True)
[
    Local(count);

    count := 0;
    While (True)
    [
        Eval(body);
        count++;
    ];

    count;
];

];

UnFence("Repeat",2);
HoldArgumentNumber("Repeat",2,2);
UnFence("Repeat",1);
HoldArgumentNumber("Repeat",1,1);




Retract("Sample",*);

Sample(list, sampleSize) :=
[
    Check(IsList(list), "Argument", "The first argument must be a list.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "Argument", "The second argument must be an integer which is greater than 0.");
    
    list := Shuffle(list);

    Take(list, sampleSize);
];


Retract("SampleSizeForTheMean",*);

SampleSizeForTheMean(standardDeviation,confidenceLevel,marginOfError) :=
[
    Local(minimumSampleSize);
    
    zScore := ConfidenceLevelToZScore(confidenceLevel);
    
    minimumSampleSize := N(((zScore*standardDeviation)/marginOfError)^2);
];



Retract("SampleSizeForTheProportion",*);

SampleSizeForTheProportion(probabilityOfSuccess,confidenceLevel,marginOfError) :=
[
    Check(probabilityOfSuccess >=0 And probabilityOfSuccess <= 1, "Argument", "The first argument must be between 0 and 1.");

    Local(minimumSampleSize,zScore);
    
    zScore := ConfidenceLevelToZScore(confidenceLevel);
    
    minimumSampleSize := N(probabilityOfSuccess*(1 - probabilityOfSuccess)*(zScore/marginOfError)^2);
];



ScheffeTest(levelsList, alpha) :=
[
    Check(IsListOfLists(levelsList), "Argument", "The first argument must be a list of lists.");
    
    Check(alpha >= 0 And alpha <= 1, "Argument", "The second argument must be a number between 0 and 1.");
    
    Local(  result,
            topOfSummary,
            pairsList,
            xBarB,
            xBarA,
            summaryTableRow,
            ssw,
            nA,
            scheffeStatisticCalculated,
            nB,
            summaryList,
            topOfPage,
            htmlJavaString,
            summaryTableRows,
            meansList,
            index,b,
            pairList,
            a,
            bottomOfPage,
            k,
            countsList,
            oneComparisonList,
            scheffeStatistic,
            bottomOfSummary,
            resultList);
    
    anova := AnovaSingleFactor(levelsList, alpha);
    
    k := Length(levelsList);
    
    scheffeStatisticCalculated := (k-1)*anova["criticalFScore"];
    
    resultList := {};
    
    resultList["scheffeStatisticCalculated"] := scheffeStatisticCalculated;
    
    meansList := {};
    
    countsList := {};
    
    ForEach(levelList,levelsList)
    [
        meansList := meansList : N(Mean(levelList));
    
        countsList := countsList : Length(levelList);
    ];
    
    pairsList := CombinationsList(1 .. Length(levelsList),2);
    
    summaryList := {};
    
    index := 1;
    
    ForEach(pairList, pairsList)
    [   
        a := pairList[1];
        
        b := pairList[2];
        
        xBarA := meansList[a];
        
        nA := countsList[a];
        
        xBarB := meansList[b];
        
        nB := countsList[b];
        
        ssw := anova["sumOfSquaresWithin"];
        
        scheffeStatistic := ScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList);
        
        oneComparisonList := {};
        
        oneComparisonList["conclusion"] := If(scheffeStatistic <= scheffeStatisticCalculated, "No Difference", "Difference");
        
        oneComparisonList["scheffeStatistic"] := scheffeStatistic;
        
        oneComparisonList["pair"] := pairList;
        
        summaryList["pair" : ToString(index)] := oneComparisonList;
        
        index++;
    ];
    
    resultList["summary"] := summaryList;
    
    
    
    
    topOfPage :=
"
    <html>
        <title>
            Scheffe Test Summary
        </title>
        
        <body>
";
    
    topOfSummary :=
"
            <h2>Scheffe Test Summary</h2>
            
            <TABLE BORDER>
                <CAPTION align=\"left\"> <h3>Summary</h3>  </CAPTION>
                
                <TR> <TH> Sample Pair</TH> <TH> Measured Scheffe Statistic </TH> <TH> Calculated Scheffe Statistic </TH> <TH> Conclusion </TH> </TR>
";

    
    summaryTableRows := "";
    
    summaryTableRow := "<TR> <TD align=\"center\"> <?Write(ToAtom(ToString(pairList[1]) : \" and \" : ToString(pairList[2])));?> </TD> <TD align=\"right\"> <?Write(summary[\"scheffeStatistic\"]);?> </TD> <TD align=\"right\"> <?Write(resultList[\"scheffeStatisticCalculated\"]);?> </TD>  <TD> <?Write(ToAtom(summary[\"conclusion\"]));?> </TD> </TR>":Nl();
    

    
    ForEach(summary, Reverse(resultList["summary"]))
    [
        summary := summary[2];

        pairList := summary["pair"];
        
        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);
    
        index++;
    ];
    
    
    bottomOfSummary :=
"
            </TABLE>
";
    
    
    bottomOfPage :=
"
        </body>         
    </html>
";
    
    htmlJavaString := JavaNew("java.lang.String",
                topOfPage : 
                topOfSummary : 
                summaryTableRows : 
                bottomOfSummary : 
                bottomOfPage);    
    
    
    
    
    resultList["html"] := htmlJavaString;
    
    
    DestructiveReverse(resultList);

];






ScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList) :=
[
    N(((xBarA-xBarB)^2)/((ssw/Sum(i,1,k,(countsList[i] - 1))*(1/nA + 1/nB))));   
];


Retract("Shuffle",*);


Shuffle(list) :=
[
    Check(IsList(list), "Argument", "Argument must be a list.");
    
    Local(index, randomIndex, temporary);
    
    list := FlatCopy(list);
    
    index := Length(list);
    
    While(index > 1)
    [
        randomIndex := RandomInteger(1,index);
        
        temporary := list[randomIndex];
        
        list[randomIndex] := list[index];
        
        list[index] := temporary;
        
        index--;
    ];      
    
    list;
];


Retract("ShuffledDeckNoSuits",*);


ShuffledDeckNoSuits() := 
[
   Shuffle(Concat(1 .. 13, 1 .. 13, 1 .. 13, 1 .. 13));
];


StandardErrorOfTheEstimate(xList,yList) :=
[   
    Check(IsList(xList), "Argument", "The first argument must be a list.");
    
    Check(IsList(yList), "Argument", "The second argument must be a list.");
    
    Check(Length(xList) = Length(yList), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    Local(n,a,b,regressionLine);
    
    regressionLine := RegressionLine(xList,yList);
    
    n := regressionLine["count"];
    
    a := regressionLine["yIntercept"];
    
    b := regressionLine["slope"];
        
    N(Sqrt((Sum(yList^2) - a*Sum(yList) - b*Sum(xList*yList))/(n-2)));
];


Retract("StandardErrorOfTheMean",*);

StandardErrorOfTheMean(sigma, sampleSize) :=
[
    Check(sigma > 0, "Argument", "The first argument must be a number which is greater than 0.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "Argument", "The second argument must be an integer which is greater than 0.");
    
    sigma/Sqrt(sampleSize);
];


Retract("StandardErrorOfTheProportion",*);

StandardErrorOfTheProportion(meanOfSampleProportions, sampleSize) :=
[
    Check(IsRationalOrNumber(meanOfSampleProportions), "Argument", "The first argument must be a number.");
    
    Check(IsInteger(sampleSize) And sampleSize > 0, "Argument", "The second argument must be an integer which is greater than 0.");
    
    Sqrt((meanOfSampleProportions*(1 - meanOfSampleProportions))/sampleSize);
];


StandardErrorOfTheSlope(xList,yList) :=
[   
    Check(IsList(xList), "Argument", "The first argument must be a list.");
    
    Check(IsList(yList), "Argument", "The second argument must be a list.");
    
    Check(Length(xList) = Length(yList), "Argument", "The lists for argument 1 and argument 2 must have the same length.");
    
    Local(standardErrorOfTheEstimate,n,xMean);
    
    standardErrorOfTheEstimate := StandardErrorOfTheEstimate(xList,yList);
    
    n := Length(xList);
    
    xMean := Mean(xList);
    
    N(standardErrorOfTheEstimate/Sqrt(Sum(xList^2) - n*xMean^2));
];




trunc(x):= [

  If(x < 0, s := -1, s := 1);
s* Floor(Abs(x));
];




intlabels(y1,y2,tnumint) := [
    diff :=y2-y1;
    x := intervals(diff,tnumint);
    bot := trunc(y1/x)*x;
  yy = bot;
  L = [];
  
  xx = 0;
  breakLoop := False;
  While (yy-x < y2 Or breakLoop = True) [
      L := Append(L, yy);
    yy := yy + x;
    
    xx++;
    If (xx > 100, breakLoop := True);
  ];
  L[i] = yy;
	L;
];




intervals(diff, NumCats) := [
    t4 := trunc(N(Ln(diff))) * 0.4342945;
  t4 = Power(10,t4);
  T := [];
  T := N(t4/10 : t4/5 : t4/2 : t4 : T);

  
  A := [];
  
  For (i := 0,i < 4, i++) [
      A := Append(A,trunc(diff/T[i]) +1);
  ];
  
  D := AbsN(10 - A[0]);
  
  index := 1;
  For (i := 1, i < 4, i++) 
  [
    if (A[i] <= 25) [
      if (A[i] > 2) [
      XX := AbsN(NumCats - A[i]);
	if (XX < D) [
        D := XX;
	  index = i+1;
	];
      ];
    ];
  ];
  T[index-1];
];





stemandleaf(x) :=
[
  Echo("Stem and Leaf Display");
  didzero := False;
   N := x.length;
  
  if (N<20)
    [
      tNumInt := 5;
    ] 
  else 
    [
      if (N < 100) 
	[
	  tNumInt := 10;
	] 
      else 
	[
	  if (N < 150) 
	    [
	      tNumInt := 15;
	    ] 
	  else
	    [
	      tNumInt := 20;
	    ];
	];
    ];
   theMax := x[N-1];
   theMin := x[0];
  alldone := False;
  if (theMax - theMin < 10) 
  [
     ratio := 1000/(theMax - theMin);
    ratio := Math.max(ratio,1000);
    ratio := trunc(Math.log(ratio) * 0.4342945);
    ratio := Math.pow(10,ratio);
    For ( i := 0, i < N , i++) 
      [
            x[i] := x[i] * ratio;
      ];
  ]
  else 
    [
      	ratio := 1;
    ];
   zcount := 0; 	
  theMin := x[0];
   abMin := Math.abs(theMin);
  theMax := x[N-1];
   Y := intervals(theMax-theMin,tNumInt);
   indexA := index +0;
  if (indexA= 2) 
    [
      Y := Y * 5;
       ncats :=5 ;
       newz := 1;
    ] 
  else 
    [
      if(indexA=3) 
	[
	  Y := Y * 2;
	   ncats := 2;
	] 
      else 
	[
	   ncats := 1;
	   newz := 0; 
	];
    ];

   cutoffs := intlabels(x[0], x[N-1], tNumInt);
  theMax := ratio * Round(theMax);
   nc := cutoffs.length;
   xx8:=0;
  While (cutoffs[nc-2] > theMax) 
    [
      nc--;
    ];
  theMax := cutoffs[nc-2];
  if (Y > AbsN(theMax)) 
    [
      nc++;
      While(Y > AbsN(theMax)) 
	[
	  xx8++;
	  if(xx8>100)[break;];
	  if (nc > Length(cutoffs)) 
	    [
	       temp := cutoffs[nc-2] - cutoffs[nc - 3];
	      temp := temp + cutoffs[nc-2];
	      cutoffs[nc-1] := temp;
	    ];
	  theMax := cutoffs[nc-1];
	  nc++;
	];
    ];
   base := trunc(theMax/Y);
   leftover := Round(theMax - base * Y);
  While (AbsN(leftover) > 10) 
    [
      leftover := AbsN(Round(leftover/10));
    ];
   theMax2 := Maximum(theMax,abMin);
   t4 := trunc(theMax2/base);
  t4 := trunc(N(Ln(t4) * .4342945));
  t4 := Power(10,t4);
   t3 := t4/10;
  if (indexA = 2) 
    [
      if (leftover >= 8)
	[
	   newz := 1;
	]
    else 
      [
	if (leftover >= 6)  
	  [
	     newz := 0;
	  ]
	else 
	  [
	    if (leftover >= 4) 
	      [
		 newz := 4;
	      ] 
	    else 
	      [
		if (leftover >= 2) 
		  [
		     newz := 3;
		  ] 
		else 
		  [
		     newz := 2; 
		  ];
	      ];
	  ];
      ];
    ]
  else 
    [
    if (indexA = 3) 
      [
	if (leftover >=5) 
	  [
	     newz := 1;
	  ] 
	else 
	  [
	     newz := 0;
	  ];
      ];
    ];
   start := False;
   LN := 1;
   LN2 := 0;
   nn := N;
   cur := cutoffs[nc-2];
   count := nc-2;
   base2 :=base;
   newline := True;
   stems := {base2};
   leaves := {""};

 
  For ( i := nn-1, i >= 0 , i--) 
    [
     it := x[i];
     dd := Round(it/t3) * t3;
     b := trunc(dd/t4);
     L := dd-t4*b;
    leftover := AbsN(Round(L/t3));
    While (leftover >= 10)
      [
	    leftover := Round(leftover/10);
      ];
    if (it >=0) 
      [
	     tt := t3;
      ]
    else 
      [
        tt := -t3;
      ];
      
     xz := b * t4 + leftover * tt;
     
    if (it<0)
      [
	    if (xz > 0 ) 
          [
            xz := xz * -1;
          ];
          xz := xz - .00001;
      ];
      
    if (xz<cur) 
    [
	    newline := True;
        While (xz<cur)
         [
	          LN ++;
              if (start) 
              [
	              LN2++;
                  leaves  := Append(leaves, "");
              ];
              temp := trunc(LN/ncats);
              temp := LN - temp*ncats;
              
              if(temp = newz)
              [
                if (base2 = 0) 
                [
                    if (didzero)
                    [
                base2 := base2 - 1;
                    ] 
                    else 
                    [
                        didzero := 1;
                    ];
               ]
               else 
                [
            base2 := base2 - 1;
                ];
          ];
	
          count := count - 1;
          
          if (count < 0)
          [
            cur := xz -1000;
          ] 
          else 
          [
            cur := cutoffs[count];
          ];
          
          if (base2 = 0)
          [
	            zcount ++;
                if ( ((indexA = 2) And (zcount >=6)) Or ((indexA = 3) And (zcount >=3)) Or ((indexA = 1) And (zcount >1)) Or ((indexA = 4) And (zcount >1))) 
                 [
                    stems := Append(stems,"-" : ToString(base2));
                 ] 
                 else 
                 [
                        stems := Append(stems, ToString(base2));
                 ];
          ] 
          else 
          [
	            stems := Append(stems, ToString(base2));
          ];
	
	   ];
      
      
      ];
      
    start := True;
    leftover := ToString(leftover);
    
    if (it>=0) 
      [
     
  leaves[LN2] := leftover : "" : leaves[LN2];
     
      ]
    else 
      [
            leaves[LN2] := leaves[LN2] : "" : leftover;
      ];
    ];
  
  For ( i := 0, i < N , i++) [
    x[i] := x[i] / ratio;
  ];
  

  Echo("Stems Leaves");
    For (i:=0, i<leaves.length, i++)[
        test := " " : stems[i];
    
      While (test.length < 8) 
       [
            test := " " : test;
       ];
       test := test : "|";
       Echo(test :  leaves[i]);
      
    ];
  

  
];

	
	

Retract("ValueToZScore",*);

ValueToZScore(value,mean,standardDeviation) :=
[
    (value - mean)/standardDeviation;
];



WeightedMean(list) :=
[

    Check(IsList(list), "Argument", "Argument must be a list.");
    
    Local( values, lastWeight, weights );
    
    values := {};
    
    weights := {};
    
    
    ForEach(element,list)
    [        
        Check(IsList(element), "Argument", "Values and their associated weights must be in a list.");
        
        Check(Length(element) = 2, "Argument", "Each value and its associated weight must be in a two element list.");
        
        values := values : element[1];

        weights := weights : element[2];
    ];
    
    Sum(values * weights)/Sum(weights);

];








ZScoreToProbability(zScore) :=
[
    zScore := N(zScore);
    
    Local( y, x, w, ZMAX, result);
    
    ZMAX := 6; 
    
    if(zScore = 0.0)
    [
        x := 0.0;
    ]
    else
    [
        y := 0.5 * AbsN(zScore);
        
        if(y > ZMAX * 0.5)
        [
            x := 1.0;
        ]
        else if(y < 1.0)
        [
            w := y * y;
            x := ((((((((0.000124818987 * w
            - 0.001075204047) * w + 0.005198775019) * w
            - 0.019198292004) * w + 0.059054035642) * w
            - 0.151968751364) * w + 0.319152932694) * w
            - 0.531923007300) * w + 0.797884560593) * y * 2.0;
        ]
        else
        [
            y := y - 2.0;
            
            x := (((((((((((((-0.000045255659 * y
            + 0.000152529290) * y - 0.000019538132) * y
            - 0.000676904986) * y + 0.001390604284) * y
            - 0.000794620820) * y - 0.002034254874) * y
            + 0.006549791214) * y - 0.010557625006) * y
            + 0.011630447319) * y - 0.009279453341) * y
            + 0.005353579108) * y - 0.002141268741) * y
            + 0.000535310849) * y + 0.999936657524;
        ];
    ];
    
        
    If(zScore > 0.0 , result := (x + 1.0) * 0.5 , result := (1.0 - x) * 0.5);
    
    result;
];



Retract("ZScoreToValue",*);

ZScoreToValue(zScore) :=
[
    -((-mean)/standardDeviation - zScore)*standardDeviation;
];


