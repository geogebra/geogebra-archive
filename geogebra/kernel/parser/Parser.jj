/* 
GeoGebra - Dynamic Mathematics for Everyone
Copyright Markus Hohenwarter, http://www.geogebra.org

This file is part of GeoGebra.

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by 
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version.
*/

/*
 * Parser.jj
 * javacc definition file to generate Parser.java
 * <BR> <BR>
 * This class provides a static function to  
 * parse a String and return an appropriate ValidExpression.
 * Direct subclasses of ValidExpression are: 
 * Command, Equation (in x, y), Parametric, Vector (for cartesian and polar points),
 * ExpressionNode (for number or vector arithmetic expressions)
 *
 * <BR><BR>
 * Some examples of possible recognized input:<BR>
 * Point   <CODE> P = (3,4) </CODE><BR>
 * Point   <CODE> P = (7; 20�) </CODE><BR>
 * Line    <CODE> g: X = (3,4) + t (7,2) </CODE><BR>
 * Line    <CODE> g: y = 3x - 9 </CODE><BR>
 * Line    <CODE> h: 5x + 7y = -2 </CODE><BR>
 * Circle  <CODE> k: (x-5)^2 + (y-2)^2 = 25 </CODE><BR>
 * Circle  <CODE> k: (x-5)� + (y-2)� = 25 </CODE><BR>
 * Conic   <CODE> c: 5x^2 - 7y^2 + 6xy - 3x + 2y = 7 </CODE>
 * Command <CODE> P = Intersect[ g, h ] </CODE>
 * Number  <CODE> r = 25 </CODE>
 * <BR><BR>
 * All arithmetic expressions (operators: +, -, *, /, ^) are 
 * valid as long as they obey the following rules:
 * Variables are x or y. Divisors and Exponents must be constant
 * numbers. The "*" operator may be omitted.
 *
 * @author Markus Hohenwarter
 * @version 10.4.2004
 */   

PARSER_BEGIN(Parser)
package geogebra.kernel.parser;

import geogebra.*;
import geogebra.main.*;
import geogebra.kernel.*;
import geogebra.kernel.arithmetic.*;
import geogebra.kernel.arithmetic3D.*;
import geogebra.util.Unicode;
import java.util.*;

public class Parser {

    private Kernel kernel;
    private Construction cons;
    private Application app;
    private boolean ExternalCASParsing = false;
    private boolean GeoGebraCASParsing = false;
    
    public Parser(Kernel kernel, Construction cons) {
    	 this ( new java.io.StringReader("") ); // dummy stream for parser initing
         this.kernel = kernel;
         this.cons = cons;
         app = kernel.getApplication();
    }   
    
    // reset for new parsing
    public void myReInit(String parseString) {
    	ReInit(new java.io.StringReader(parseString));    	
    	ExternalCASParsing = false;
    	GeoGebraCASParsing = false;
    }

    /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraExpression(String parseString) throws ParseException {           
        myReInit( parseString );                         
        return buildValidExpression();     
    }
    
     /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraCAS(String parseString) throws ParseException {           
        myReInit( parseString );
        // parse x^2 + y^2 as an expression and don't throw Incomplete Equation error
        GeoGebraCASParsing = true;                        
        return buildCASExpression();     
    }        
    
    /**
     * Parses a MathPiper String and returns a ValidExpression Object     
     */
    public ValidExpression parseMathPiper(String parseString) throws ParseException {           
        myReInit( parseString ); 
        ExternalCASParsing = true;                         
        return buildMathPiperExpression();     
    }

    /**
     * Parses a Maxima String and returns a ValidExpression Object     
     */
    public ValidExpression parseMaxima(String parseString) throws ParseException {           
        myReInit( parseString ); 
        ExternalCASParsing = true;                         
        return buildMaximaExpression();     
    }
    
    /**
     * Parses a String and returns a Function Object     
     */
    public Function parseFunction(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        return function();      
    }

    /**
     * Parses a String and returns a Function Object     
     */
    public FunctionNVar parseFunctionNVar(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        return functionNVar();      
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseCmdExpression(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        return cmdexpression();      
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseExpression(String parseString) 
    throws ParseException {    
        myReInit( parseString);                           
        return expression();      
    }
    
    /**
     * Parses a String if it is a label
     */
    public String parseLabel(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        return label();      
    }    
}
PARSER_END(Parser)



SKIP : {
    " " 
  | "\r"
  | "\t"
  | "\n"
}

TOKEN : {
    < EOL: ";" >
}

/* OPERATORS */
TOKEN :  {   
    < ASSIGNMENT: ( ":=") >
  | < VERTICAL_BAR: "|" >
  | < NOT: ("\u00ac") > 
  | < OR:		("||" | "\u2228" ) >
  | < AND:		("&&" | "\u2227" ) >
  | < EQUAL_BOOLEAN: ("==" | "\u225f" ) >
  | < NOT_EQUAL: ("!=" | "\u2260" ) >
  | < IS_ELEMENT_OF: "\u2208" >
  | < CONTAINS: "\u2286" >
  | < CONTAINS_STRICT: "\u2282" >
  | < SET_DIFFERENCE: "\\" >
  | < LESS:		"<" >
  | < GREATER:	">" >
  | < LESS_EQUAL: ("<=" | "\u2264") >
  | < GREATER_EQUAL: (">=" | "\u2265") >
 // | < INEQUALITY: ( < LESS > | < LESS_EQUAL > | < GREATER_EQUAL > | < GREATER > ) >
  | < PARALLEL: "\u2225" >
  | < PERPENDICULAR: "\u22a5" >
  | < EQUAL:    "=" >
  | < PLUS:     "+" >
  | < MINUS:    ("-"  | "\u2013" | "\u2212") >
  | < SUPERSCRIPT_MINUS: "\u207b" >
    // dot operators for multiplication sign
  | < MULTIPLY: ("*" | "\u22c5" | "\u2219") >
  | < VECTORPRODUCT: "\u2297" >
  | < DIVIDE:   "/" >
  | < POWER:    "^" >  
  | < FACTORIAL: "!" >  
  | < UNDEFINED: ( "?" | "\ufffd" | "Undefined" | "NaN" | "und" ) >
//  | < POWER0:   "\u2070" >
//  | < POWER1:   "\u00b9" >
//  | < SQUARED:  "\u00b2" >
//  | < CUBED:    "\u00b3" >
//  | < POWER4:   "\u2074" >
//  | < POWER5:   "\u2075" >
//  | < POWER6:   "\u2076" >
//  | < POWER7:   "\u2077" >
//  | < POWER8:   "\u2078" >
//  | < POWER9:   "\u2079" >
  | < POWERN: (<SUPERSCRIPT_MINUS>)? ( <INDEXDIGIT> )+ >
  | < #INDEXDIGIT:                                     // unicode digits
       [ "\u2070","\u2074"-"\u2079","\u00b9","\u00b2","\u00b3"] >
  | < PI:       ( "pi" | "Pi" | "\u03c0" | "%pi") >
  | < E:        ("\u212f" | "%e") >  
  | < DEGREE:   ( "\u00b0" ) >
  | < INFINITY: ("\u221e" | "Infinity" | "inf" | "infinity") >
  | < MINUS_INFINITY: ("minf") >
  | < RAD:      "rad" >
  | < DERIVATIVE: "'" >
  | < TRUE:     ( "true" | "True" ) >
  | < FALSE:    ( "false" | "False" ) >
  | < DECIMAL_POINT:    ( "." | "\u066b" ) > // Arabic decimal point
  | < COMMA:    ( "," | "\u060c" ) > // Arabic comma
}

TOKEN : {      
  		< VARX: "x" >
  |		< VARY: "y" >
  |		< VARZ: "z" >
  |     < FLOAT: <INTEGER> ( <DECIMAL_POINT> <INTEGER> )? 
        | <DECIMAL_POINT> <INTEGER> 
        | <INTEGER> <DECIMAL_POINT>
        >
  |     < EFLOAT: <FLOAT> ("E") (<PLUS> | <MINUS>)? <INTEGER> >
  |     < PERCENTAGE: <FLOAT> "%" >
  |     < INTEGER: ( <DIGIT> )+ >
  |     < #DIGIT:                                     // unicode digits
       [
        "\u0030"-"\u0039", // Roman
        "\u0660"-"\u0669", // Arabic-Indic
        "\u06f0"-"\u06f9", // Extended Arabic-Indic
        "\u0966"-"\u096f", // Devanagari (Hindi)
        "\u09e6"-"\u09ef", // Bengali
        "\u0a66"-"\u0a6f", // Gurmukhi (Punjabi)
        "\u0ae6"-"\u0aef", // Gujurati
        "\u0b66"-"\u0b6f", // Oryia
        "\u0be6"-"\u0bef", // Tamil
        "\u0c66"-"\u0c6f", // Telugu
        "\u0ce6"-"\u0cef", // Kannada
        "\u0d66"-"\u0d6f", // Malayalam
        "\u0e50"-"\u0e59", // Thai
        "\u0ed0"-"\u0ed9", // Lao
        "\u1040"-"\u1049", // Myanmar (Burmese)
        "\u0f20"-"\u0f29", // Tibetan
        "\u1b50"-"\u1b59", // Balinese
        "\u1bb0"-"\u1bb9", // Sudanese
        "\u1c40"-"\u1c49", // Lepcha
        "\u1c50"-"\u1c59", // Ol Chiki
        "\u17e0"-"\u17e9", // Khmer
        "\u1810"-"\u1819", // Mongolian
        "\ua8d0"-"\ua8d9"  // Saurashtra
       ]
> 
}   

TOKEN : { 
 	// labels for cells in the spreadsheet
 	<SPREADSHEET_LABEL: ("$")?(["A"-"Z"]|["a"-"z"])+("$")?(["0"-"9"])+ > // e.g. B12
 | 
 	// standard case: labels for GeoElements and command names
   < LABEL:  
    <LETTER> ( <LETTER> | <DIGIT> | "'" )* (<INDEX>)? (<LETTER> | <DIGIT>)*>
 // |  < #INDEX:  "_" (  <CHAR>  | ("{" (<CHAR>)+ "}") )  >  
 |  < #INDEX:  "_" (  <CHAR>  | ("{" (~["}"])+ "}" ) )  >  
 | < #LETTER:  // unicode letters
       [
        "$", // for absolute references in the spreadsheet
        "\u0041"-"\u005a",      //upper case (A-Z)
        "\u0061"-"\u007a",      //lower case (a-z)
        "\u00b7",   			// middle dot (for Catalan)
        "\u00c0"-"\u00d6",      //accentuated letters
        "\u00d8"-"\u01bf",		//accentuated letters
        "\u01c4"-"\u02a8",		//accentuated letters
        "\u0391"-"\u03f3", 		// Greek 
       	"\u0401"-"\u0481",		// Cyrillic
        "\u0490"-"\u04f9",		// Cyrillic
        "\u0531"-"\u1ffc", 	    // a lot of signs (Arabic, accentuated, ...)
        "\u3041"-"\u3357", 	 	// Asian letters	 
        "\u4e00"-"\ud7a3",		// Asian letters
        "\uf71d"-"\ufa2d",		// Asian letters
        "\ufb13"-"\ufdfb",		// Armenian, Hebrew, Arabic
        "\ufe80"-"\ufefc",		// Arabic
        "\uff66"-"\uff9d",		// Katakana
        "\uffa1"-"\uffdc"		// Hangul
       ] >
       
}
 


// labels for function names
TOKEN: {
    < X_FUNC:  "x(" | "xcoord(" >
|	< Y_FUNC:  "y(" | "ycoord("  > 
|	< Z_FUNC:  "z(" | "zcoord("  > 
|	< COS_FUNC: ( "cos(" | "Cos(" ) > 
|	< COSN_FUNC: ( "cos" | "Cos" ) ( < POWERN > ) + "(" > 
|	< SIN_FUNC: ( "sin(" | "Sin(" ) > 
|	< SINN_FUNC: ( "sin" | "Sin" ) ( < POWERN > ) + "(" > 
|	< TAN_FUNC: ( "tan(" | "Tan(" ) > 
|	< TANN_FUNC: ( "tan" | "Tan" ) (< POWERN > ) + "(" > 
|	< CSC_FUNC: ( "csc(" | "Csc(" | "cosec(" | "Cosec(") > 
|	< CSCN_FUNC: ( "csc" | "Csc" | "cosec" | "Cosec") (< POWERN > ) + "("> 
|	< SEC_FUNC: ( "sec(" | "Sec(" ) > 
|	< SECN_FUNC: ( "sec" | "Sec" ) (< POWERN > ) + "(" >  
|	< COT_FUNC: ( "cot(" | "Cot(" ) > 
|	< COTN_FUNC: ( "cot" | "Cot" ) (< POWERN > ) + "(" >  
|	< CSCH_FUNC: ( "csch(" | "Csch(" | "cosech(" | "Cosech(") > 
|	< CSCHN_FUNC: ( "csch" | "Csch" | "cosech" | "Cosech") (< POWERN > ) + "(" > 
|	< SECH_FUNC: ( "sech(" | "Sech(" ) > 
|	< SECHN_FUNC: ( "sech" | "Sech" ) (< POWERN > ) + "(" > 
|	< COTH_FUNC: ( "coth(" | "Coth(" ) > 
|	< COTHN_FUNC: ( "coth" | "Coth" ) (< POWERN > ) + "(" > 
|	< ACOS_FUNC: ( "acos(" | "arccos("| "arcos(" | "ArcCos(" )> 
|	< ASIN_FUNC: ( "asin(" | "arcsin(" | "ArcSin(" ) > 
|	< ATAN_FUNC: ( "atan(" | "arctan(" | "ArcTan(" )> 
|	< ATAN2_FUNC: ( "atan2(" | "arctan2(" | "ArcTan2(" )> 
|	< COSH_FUNC: ( "cosh(" | "Cosh(" ) > 
|	< COSHN_FUNC: ( "cosh" | "Cosh" ) (< POWERN > ) + "(" > 
|	< SINH_FUNC: ( "sinh(" | "Sinh(" ) > 
|	< SINHN_FUNC: ( "sinh" | "Sinh" ) (< POWERN > ) + "(" > 
|	< TANH_FUNC: ( "tanh(" | "Tanh(" ) > 
|	< TANHN_FUNC: ( "tanh" | "Tanh" ) (< POWERN > ) + "(" > 
|	< ACOSH_FUNC: ( "acosh(" | "arccosh(" | "arcosh(" | "ArcCosh(" ) > 
|	< ASINH_FUNC: ( "asinh(" | "arcsinh(" | "ArcSinh(" ) > 
|	< ATANH_FUNC: ( "atanh(" | "arctanh(" | "ArcTanh(" ) > 
|	< EXP_FUNC: ( "exp(" | "Exp(" ) > 
|	< LOG_FUNC: ( "log(" | "ln(" | "Ln(" ) > 
|	< LD_FUNC:    "ld("  > 
|	< LG_FUNC:    "lg("  > 
|	< SQRT_FUNC: ( "sqrt(" | "Sqrt(" ) > 
|	< CBRT_FUNC:   "cbrt("  > 
|	< ABS_FUNC:  ( "abs(" | "Abs(" ) > 
|	< SGN_FUNC:  ( "sgn(" | "sign(" | "Sign(" ) > 
|	< FLOOR_FUNC: ( "floor(" | "Floor(" ) > 
|	< CEIL_FUNC:  ( "ceil(" | "Ceil(" ) > 
|	< CONJUGATE_FUNC:  ( "conjugate(" | "Conjugate(" ) > 
|	< ARG_FUNC:  ( "arg(" | "Arg(" ) > 
|	< ROUND_FUNC: ( "round(" | "Round(" ) > 
|	< GAMMA_FUNC: ( "gamma(" | "Gamma(" ) > 
|	< RANDOM_FUNC:  "random()"  >
|	< DERIV_MP:  "Deriv()"  >  // may be returned by MathPiper
| 	< FUNCTION_LABEL: ( <SPREADSHEET_LABEL> | <LABEL> ) "(" >
}

 TOKEN : {
 < TEXT: "\""  (<CHAR>)* "\"" > |
 < #CHAR: ["\u0000"-"\u0021", "\u0023"-"\uffff"]  >    
}
                          
String label():
{     
    Token t;
}
{         	  
       ( t = <SPREADSHEET_LABEL> |  t = <LABEL> )
        {  return t.image;   }
}
     

/**
 * for GeoGebra input field
 * validexpression =    
 *                  labellist() = command() |           // e.g. {A,B} = Intersect[c, g]
 *                      <LABEL> : parametric() |        // e.g. X = (3,2) + t (2,1)              
 *                      <LABEL> = expression()      // arithmetic expression of floats, vectors and vars
 *                      <LABEL> : equation()        // equation in x an y
 						<LABEL>(x) = function()   // function in x, e.g. f(x) = 3x^3 - sqrt(x)
 */
ValidExpression buildValidExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Token c = null;
    Vector labels = new Vector();
} 
{         
     (  
             
              
        // f(x) =  x^2 + 3	
        LOOKAHEAD(2147483647)
        ve = functionExpressionnode()          
     |             
     	// spreadsheet range like A1:B2
		LOOKAHEAD (3)
		ve = spreadsheetRange()
     |     
        // h: X = (3,2) + t (5,1)
      	LOOKAHEAD(2147483647) 
      	(l = <SPREADSHEET_LABEL> | l = <LABEL>) (":" | <ASSIGNMENT> )  ve = parametric()      
     |     
        // g: 3x + y = 7 
        LOOKAHEAD(2147483647)      
        (l = <SPREADSHEET_LABEL> | l = <LABEL>)  (":" | <ASSIGNMENT> )  ve = equation()        
    |          
        // special case "A: (3,2)" should become a point  
        // CAS assignment "a := 5" should be supported too                                     
	  	LOOKAHEAD(2147483647)  
	    (l = <SPREADSHEET_LABEL> | l = <LABEL>) (":" | <ASSIGNMENT> )  ve = expression()   
	 |     
        // distingiush <LABEL> = expressionnode()               and  
        //             expressionnode() = expressionnode()      (Equation)
        //
        // equation without label and only one variable on the lhs
        // could be expression too!!!
        // eg. t = 2 x     or     t = 2 s
        
     LOOKAHEAD(2147483647)
        lhs = expressionnode() <EQUAL> rhs = expressionnode()
        {             
            // maybe expression
            if (lhs.isSingleVariable() && !rhs.includesPolynomial()) {                                  
                // it's an expression
                ve = rhs;
                ve.setLabel(((Variable)lhs.evaluate()).getName());                         
            } else {
                // it's a polynomial
                ve = new Equation(kernel, lhs, rhs); 
            }
        }
     |
        LOOKAHEAD(2147483647)
        ve = cmdexpression()     
     |	     
        LOOKAHEAD(2147483647)
        labels = labellist() "=" ve = command()    	  	                                       	                       	 	 
   	 |
        LOOKAHEAD(2147483647)                               
	  	ve = cartesianvector_special()
	|
	 	 LOOKAHEAD(2147483647)    
	 	 	ve = polarvector_special()  
    )                     
    ( <EOL> | <EOF> )     
    {                      
        if (labels.size() > 0) ve.addLabel(labels);  // command with ouput labels
        else if (ve.labelCount() == 0) ve.addLabel(l.image);  // standard case                         
        return ve;
    }    
}

/**
 *  parse GeoGebra CAS input
 */
ValidExpression buildCASExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
} 
{         
    (
        // CAS function
        // f(a) := a^2 + 3a
        LOOKAHEAD(2147483647)   
        ve = casFunction()
    |	   
       	// labeled equation, e.g. g: 3x + y = 7
       	LOOKAHEAD(2147483647)   
       	l = casLabel() ( ":" | <ASSIGNMENT>) ve = equation()  
    |
        // assignment         
        // b := 27 + c
        LOOKAHEAD(2147483647)
		l = casLabel() <ASSIGNMENT> ve = expressionnode()  
 	|	   
       	// equation, e.g. 3x + y = 7
       	LOOKAHEAD(2147483647)   
       	ve = equation()
    | 
    	// expression
    	// 5a + 3    
    	LOOKAHEAD(2147483647)
    	ve = expressionnode()     	     	     
	)                     
    ( <EOL> | <EOF> )     
    {   
    	// remember label      
    	if (l.image != null)             
        	ve.addLabel(l.image);                          
        return ve;
    }    
}


/**
 * convert MathPiper String to GeoGebra string
 */
ValidExpression buildMathPiperExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
} 
{         
    (     
		// try to parse MathPiper string as standard GeoGebra expression 
    	ve = expressionnode()     	     	   
	)                     
    ( <EOL> | <EOF> )     
    {       	                         
        return ve;
    }    
}

/**
 * convert Maxima String to GeoGebra string
 */
ValidExpression buildMaximaExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token start,sign = null,end;
} 
{         
    (
    	// try to parse Maxima string as standard GeoGebra expression 
    	ve = expressionnode() 
	)                     
    ( <EOL> | <EOF> )     
    {       	                         
        return ve;
    }    
}

/**
 * convert Solve results like {x==5, x==7} to simple list {5, 7} 
 *
ValidExpression MathPiperSolveResult() : 
{    
	ExpressionValue ev;
	MyList myList;
} 
{         
    LOOKAHEAD(5)
   (
     // empty list
      "{" "}"  
      {   
           return new MyList(kernel);               
       }
    )
    |
   ( 
    // list with solutions like {x==5, x==7}
    "{"
         casLabel() <EQUAL_BOOLEAN> (ev = plusminusnode())    
       {   
            myList = new MyList(kernel);         
            myList.addListElement(ev);
        }
       ( <COMMA> casLabel() <EQUAL_BOOLEAN> (ev = plusminusnode()) 
       	 {
       		myList.addListElement(ev); 
       	 } 
        )*
    "}"
    {  return myList;  } 
    )  
}
*/

/**
 * (<VARX> | <VARY> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
Token casLabel():
{
  Token l;
}
{
	(l = <VARX> | l = <VARY> | l = <LABEL> | l = <SPREADSHEET_LABEL>)
	{
	  return l;
	}
}

/**
 * command =     <LABEL> [ argument (, argument)* ]  
 */
Command command():
{     
    Command c;
    Token t;
    ExpressionNode en;
}
{   
	(
	    (t = <SPREADSHEET_LABEL> | t = <LABEL>)
	    {   c = new Command(kernel, t.image, true );    } 
	    ("[" 
	       ( en = cmdexpression()  { c.addArgument( en ); } )?
	        ( <COMMA> en = cmdexpression() { c.addArgument( en ); } )*
	    "]") 
	    { return c; }	 
    |
     	(t = <FUNCTION_LABEL>) // includes (
	    {   c = new Command(kernel, t.image.substring(0,t.image.length()-1), true );    } 
	    (   ( en = cmdexpression()  { c.addArgument( en ); } )?
	        ( <COMMA> en = cmdexpression() { c.addArgument( en ); } )*
	    ")" )
	    { return c; }
	)
}

/**
 * labellist =    { <LABEL> (, <LABEL>)* }  
 */
Vector labellist():
{         
    Token t;    
    Vector labels;
}
{
(( 
    "{" (t=<SPREADSHEET_LABEL> | t=<LABEL>) 
        {   
            labels = new Vector(); labels.add(t.image);  
        }
     ( <COMMA> (t=<SPREADSHEET_LABEL> | t=<LABEL>)   { labels.add(t.image); } )*
    "}" 
)
    |    
( 
    (t=<SPREADSHEET_LABEL> | t=<LABEL>)   
        {   
            labels = new Vector(); labels.add(t.image);  
        }
     ( <COMMA> (t=<SPREADSHEET_LABEL> | t=<LABEL>)   { labels.add(t.image); } )*
))
     { return labels; }
}


/**
 * parametric =   <PARAMETRICVAR> = vector + <LABEL> * vector  |
 *                <PARAMETRICVAR> = vector - <LABEL> * vector |
 */
Parametric parametric():
{         
    ExpressionValue P, v;
    ExpressionValue temp;
    Token s, par;    
}
{    
    <LABEL> <EQUAL> P = multterm()
    ( 
     (s = <PLUS> | s = <MINUS>) par = <LABEL> (<MULTIPLY>)? v = expression()
         {                                    
            if (s.kind == MINUS) 
                v = new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), ExpressionNode.MULTIPLY, v);                    
            return new Parametric(kernel, P, v, par.image );                
         }
    ) 
}


/** NOT USED BY NOW
 * normalvectorform =   <PARAMETRICVAR> vector  = vector 
 
NormalVectorForm normalvectorform():
{         
    ExpressionNode left, right;
    ExpressionValue temp;
}
{    
    <PARAMETRICVAR> (<MULTIPLY>)? left = enterm()  <EQUAL> right = expressionnode()           
         {                        
            // check if left is VectorValue and right is NumberValue
            temp = left.evaluate();
            if (!(temp instanceof VectorValue)) {
                String [] str = { "VectorExpected", temp.toString() };
                throw new MyParseError(app, str);
            }

            temp = right.evaluate();
            if (!(temp instanceof NumberValue)) {
                String [] str = { "NumberExpected", temp.toString() };
                throw new MyParseError(app, str);
            }        
            
            return new NormalVectorForm( left, right );                
         }   
}
*/

/******************************************************************
 * ARTIHMETIC FOR NUMBERS AND 2D VECTORS WITH VARIABLES
 * plus
 * ARTIHMETIC FOR POLYNOMIALS WITH VARIABLES "x" AND "y"
 * exponents must be integers >= 0
 * divisors must be simplifyable to numbers
 ******************************************************************/


/**
 * equation =       expression = expression
 */
Equation equation():
{
    ExpressionNode lhs, rhs;
}
{    
    lhs = expressionnode() <EQUAL> rhs = expressionnode()
        {             
            return new Equation(kernel, lhs, rhs); 
        }
}




/**
 * expression = expressionnode
 */
ExpressionNode expression():
{
    ExpressionNode rhs;
}
{    
    rhs = expressionnode()              
    {
        if (!GeoGebraCASParsing && rhs.includesPolynomial()) {
        	throw new MyError(app, "IncompleteEquation");
        }
        
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
		//rhs.resolveVariables();
        return rhs;
    }
}

/**
 * cmdexpression = expressionnode 
 * (may only return Function)
 */
ExpressionNode cmdexpression():
{
    ExpressionValue ev;
    ExpressionNode en;
}
{    
 (
 	// equation like: 3x + 4 = 7
 	LOOKAHEAD (2147483647) 
 	ev = equation()
 	{ 
 		// TODO: remove
 		return new ExpressionNode(kernel, ev);  	
 	} 
  |   
    // expression 
    en = expressionnode()              
    {
        if (!GeoGebraCASParsing) {
          	TreeSet<String> vars = en.getPolynomialVars();
          	switch (vars.size()) {
          		case 0: break;
          		case 1: // single var function
	        		return new ExpressionNode(kernel, new Function(en, new FunctionVariable(kernel, vars.first())));

				default: // multivariate function
					FunctionVariable [] funs = new FunctionVariable[vars.size()];    	
					int i=0;
			    	for (String var : vars) {
			    		funs[i++] = new FunctionVariable(kernel, var);
			    	}
			    	return new ExpressionNode(kernel, new FunctionNVar(en, funs));
			    	
          	}
        	//throw new MyError(app, "IncompleteEquation");
        }
        
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ i^2, i , 1, 10 ]
        // rhs.resolveVariables();  
        return en;     
    }
)
}

/**
 * function = functionExpressionnode 
 */
Function  function():
{
    ExpressionNode rhs;
    Token l = null;
    Function f;
}
{          
(
	   // f(x) =  x^2 + 3	
	 	 rhs = functionExpressionnode()
	    {
	    	if (rhs.getLeft() instanceof Function) {
	    		f = (Function) rhs.getLeft();
	    	}
	    	else {
		        f = new Function(rhs);		        
		    }
		    f.setLabel(rhs.getLabel());	       
		    return f;
	    }   
)	   
}

/**
 * functionNVar = functionExpressionnode 
 */
FunctionNVar  functionNVar():
{
    ExpressionNode rhs;
    Token l = null;
    FunctionNVar f;
}
{          
(
	   // f(x) =  x^2 + 3	
	 	 rhs = functionExpressionnode()
	    {
	    	if (rhs.getLeft() instanceof FunctionNVar) {
	    		f = (FunctionNVar) rhs.getLeft();
	    	}
	    	else {
		        f = new FunctionNVar(rhs);		        
		    }
		    f.setLabel(rhs.getLabel());	       
		    return f;
	    }   
)	   
}

/**
 * function = 	f(var1, var2) = expressionnode 
 *				f(var) := expressionnode 
 *				f(var) = command
 */
ExpressionNode functionExpressionnode():
{
    ExpressionNode rhs;
    Token funName = null;
    Token varName = null;
    ArrayList<String> localVars;
    Token var;
}
{          
(
  		// single or multi-variable function definition
	   // f(a) =  a^2 + 3
	   // g(x,y) := x * y
	   funName = <FUNCTION_LABEL> // includes "(" at end	   
	   		// local variables	   		(( varName =  <VARX> | varName =  <SPREADSHEET_LABEL> | varName = <LABEL> )
	   		  { localVars = new ArrayList<String>(); localVars.add(varName.image); } )
			// optional second variable						 (<COMMA> ( varName =  <VARX> |  varName =  <VARY> | varName =  <SPREADSHEET_LABEL> | varName = <LABEL> )
			 { localVars.add(varName.image); } )* 
			// closing ) and assignment with expressionnode
	   		 ")" ( <EQUAL > | <ASSIGNMENT> ) rhs = expressionnode()
	    {
	      	// allow f(y) in CAS but not in GeoGebra
		//	if (!ExternalCASParsing && !GeoGebraCASParsing && "y".equals(varName.image)) 
	    //    	throw new MyError(app, "InvalidInput");
	    
		  	String funLabel = funName.image.substring(0,funName.image.length()-1);	 

			// command: return function expression
			// function: wrap function in ExpressionNode
	    	if (!(rhs.getLeft() instanceof Command)) {
				// number of vars
				int n = localVars.size();
				
				FunctionVariable[] funVar = new FunctionVariable[n];
		    	for (int i=0;i<n; i++){
		    		funVar[i] = new FunctionVariable(kernel);
		    		funVar[i].setVarString(localVars.get(i));
		    	}

	    	    switch (n) {
	    	      case 1: // single variable function					
					Function fun = new Function(rhs, funVar[0]);
					fun.setLabel(funLabel);
					rhs = new ExpressionNode(kernel, fun);
					break;

	       		  default: // multi variable function
	       			FunctionNVar funn = new FunctionNVar(rhs, funVar);					funn.setLabel(funLabel);					rhs = new ExpressionNode(kernel, funn);
	       			break;	    	    }    			   
       		}

       		rhs.setLabel(funLabel);
       		return rhs;
	    }   
)
}

/**
 * CAS function = 	label(var) := expressionnode 
 */
FunctionNVar casFunction():          
{
    ExpressionNode rhs;
    Token funName = null;
    Token varName = null;
    ArrayList<String> localVars;
    Token var;
}
{          
(
  		// single or multi-variable function definition
	   // f(a) =  a^2 + 3
	   // g(x,y) := x * y
	   funName = <FUNCTION_LABEL> // includes "(" at end	   
	   		// local variables
	   		(( varName =  <VARX> | varName =  <VARY> | varName =  <SPREADSHEET_LABEL> | varName = <LABEL> )
	   		  { localVars = new ArrayList<String>(); localVars.add(varName.image); } )
			// optional second variable			
			 (<COMMA> ( varName =  <VARX> | varName =  <VARY> | varName =  <SPREADSHEET_LABEL> | varName = <LABEL> )
			 { localVars.add(varName.image); } )* 
			// closing ) and assignment with expressionnode
	   		 ")" ( <ASSIGNMENT> ) rhs = expressionnode()
	    {
		  	String funLabel = funName.image.substring(0,funName.image.length()-1);	 

			// number of vars
			int n = localVars.size();
			
			FunctionVariable[] funVar = new FunctionVariable[n];
	    	for (int i=0;i<n; i++){
	    		funVar[i] = new FunctionVariable(kernel);
	    		funVar[i].setVarString(localVars.get(i));
	    	}

    	    switch (n) {
    	      case 1: // single variable function					
				Function fun = new Function(rhs, funVar[0]);
				fun.setLabel(funLabel);
				return fun;

       		  default: // multi variable function
       			FunctionNVar funn = new FunctionNVar(rhs, funVar);
				funn.setLabel(funLabel);
				return funn;
    	    }
	    }   
)	 
}     


/**
 *  expression =  term <OR> term
 */
ExpressionNode expressionnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = ANDterm()                 
    ( <OR>  f = ANDterm()
        {                
	         ret = new ExpressionNode(kernel, ret, ExpressionNode.OR, f);                   
        }
    )*
    { 
    	ExpressionNode en;
    	if (ret.isExpressionNode())
    		en = (ExpressionNode) ret;
    	else
    		en = new ExpressionNode(kernel, ret);
    	
    	//en.expandEquationExpressions();
    	if (ExternalCASParsing)
    		en.simplifyLeafs();
    	return en; 
    }
}

/**
 *  expression =  term +/- term
 */
ExpressionNode expressionnodePlusMinus():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = plusminusnode()                 
    
    { 
    	ExpressionNode en;
    	if (ret.isExpressionNode())
    		en = (ExpressionNode) ret;
    	else
    		en = new ExpressionNode(kernel, ret);
    	
    	//en.expandEquationExpressions();
    	if (ExternalCASParsing)
    		en.simplifyLeafs();
    	return en; 
    }
}

/**
 *  expressionOrEquation =  equation | expressionnode 
 */
ExpressionNode expressionOrEquation():
{
    ExpressionNode en, rhs;
}
{ 
 		en = expressionnode()
    	(  <EQUAL> rhs = expressionnode()
	        {             
	            en = new ExpressionNode(kernel, new Equation(kernel, en, rhs)); 
	        }    
    	)?
	{                
		return en;             
	}
}

/**
 * ANDterm =   COMPAREterm <AND> COMPAREterm 
 */
ExpressionValue ANDterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = COMPAREterm()           
    ( <AND>  f = COMPAREterm() 
        {
        	ret = new ExpressionNode(kernel, ret, ExpressionNode.AND, f);             
        }     
    )*
    { return ret; }  
}

/**
 * COMPAREterm =   plusminusnode ("==" | "<" | "<=" | ">" | ">=") plusminusnode 
 */
ExpressionValue COMPAREterm():
{
    ExpressionValue left, right;
    ExpressionNode result;   
    Vector<ExpressionNode> andList = null; // support multiple comparisons like 3 < x < 7
}
{
    left = plusminusnode()  
    (         
       (         (<EQUAL_BOOLEAN>  right = plusminusnode()
    	 {            
    	   if (ExternalCASParsing)
    	       result = new ExpressionNode(kernel, new Equation(kernel, left, right));
    	   else
           	   result = new ExpressionNode(kernel, left, ExpressionNode.EQUAL_BOOLEAN, right);  
         }
       )   
     |   
       (<NOT_EQUAL>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.NOT_EQUAL, right);  
         }
       )   
     |   
       (<IS_ELEMENT_OF>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.IS_ELEMENT_OF, right);  
         }
       )   
     |   
       (<CONTAINS>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.CONTAINS, right);  
         }
       )   
     |   
       (<CONTAINS_STRICT>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.CONTAINS_STRICT, right);  
         }
       )   
     |   
       (<SET_DIFFERENCE>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.SET_DIFFERENCE, right);  
         }
       )   
     |   
       (<LESS>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.LESS, right);  
         }
       ) 
     |
       (<GREATER>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.GREATER, right);  
         }
       ) 
     |
       (<LESS_EQUAL>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.LESS_EQUAL, right);  
         }
       ) 
     |
       (<GREATER_EQUAL>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.GREATER_EQUAL, right);  
         }
       ) 
      |
   	    (<PARALLEL>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.PARALLEL, right);  
         }
         ) 
      |
   	    (<PERPENDICULAR>  right = plusminusnode()
    	 {            
           result = new ExpressionNode(kernel, left, ExpressionNode.PERPENDICULAR, right);  
         }
        )
     )                    
     {
        // store all AND parts
        // e.g. 3 < x < 7 should get stored as 3 < x && x < 7
      	if (andList == null)
			andList = new Vector<ExpressionNode>();
		andList.add(result);
		left = right;
     }
    )* 
    {
      if (andList != null) {
  		// build AND ExpressionNode tree, e.g. 3 < x && x < 7
        left = andList.get(0);
        for (int i=1; i < andList.size(); i++) {			left = new ExpressionNode(kernel, left, ExpressionNode.AND, andList.get(i));
        }   
      }
      return left;
    }  
}

/**
 *  expression =    term + term |
 *                  term - term
 */
ExpressionValue plusminusnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = multterm()                 
    (( x = <PLUS> | x = <MINUS> ) f = multterm()
        {                       
            if (x.kind == PLUS) 
                ret = new ExpressionNode(kernel, ret, ExpressionNode.PLUS, f);  
            else
                ret = new ExpressionNode(kernel, ret, ExpressionNode.MINUS, f);  
        }
    )*
    { 
    	//ret.simplifyLeafs();
    	return ret; 
    }
}

/**
 * multterm =   divterm * divterm 
 */
ExpressionValue multterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = divterm()           
    (                 
     ( x = <MULTIPLY> | x = <VECTORPRODUCT> ) f = divterm() 
        {
            if (x.kind == MULTIPLY) {
                ret = new ExpressionNode(kernel, ret, ExpressionNode.MULTIPLY, f);   
            } else {
                ret = new ExpressionNode(kernel, ret, ExpressionNode.VECTORPRODUCT, f);  
            }
        }
     |
     f = powerdivterm()
        { 
               ret = new ExpressionNode(kernel, ret, ExpressionNode.MULTIPLY, f);  
         }	
    )*
    { return ret; }  
}

/**
 * divterm =  unary / unary
 */
ExpressionValue divterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = enunary()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, ExpressionNode.DIVIDE, f); 
        }	
    )*
    { return ret; }  
}

/**
 * powerdivterm =  power / unary
 */
ExpressionValue powerdivterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = enpower()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, ExpressionNode.DIVIDE, f); 
        }	
    )*
    { return ret; }  
}

/**
 * unary =  -power    |
 * 	        +power    | 	
 *          power
 */
ExpressionValue enunary():        
{
    ExpressionValue e;
    Token c;
}
{
    <MINUS> e = enpower()
        { // -e  = -1*e
          return new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), ExpressionNode.MULTIPLY, e);              
        }
|
   <PLUS> e = enpower()
        { // +e  = e
          return e;              
        }
|
    e = enpower()
        {
            return e;
        }
}

/**
 * power =    element                 |
 *          element ^ power           
 */
ExpressionValue enpower():
{
    ExpressionValue ret, f;
    Token c;
    
}
{	
    ret = enfactorial()         
    (   
    	( c = <POWERN> )
        {            
            return new ExpressionNode(kernel, ret, ExpressionNode.POWER, 
            			 new MyDouble(kernel, c.image));  
	    } 
    |       
    	(LOOKAHEAD(<POWER>) <POWER> f = enunary()
        {            
        	// check if we have e^
        	if (ret.isExpressionNode()) {
        		ExpressionNode en = (ExpressionNode) ret;
	        	if (en.isLeaf() &&  en.getLeft() instanceof MyDouble) {
	        		MyDouble num = (MyDouble) en.getLeft();
	        		if (num.getDouble() == Math.E) {      	
	        	    	return new ExpressionNode(kernel, f, ExpressionNode.EXP, null);        		
	        		} 
	        	}       
        	}
        	
        	// standard case ret^f
            return new ExpressionNode(kernel, ret, ExpressionNode.POWER, f);                              
        }      
    	)*
    )     
    { return ret; }    
}

/**
 * factorial =  <NOTterm> |
 *              <NOTterm> !
 */
ExpressionValue enfactorial():
{   
    ExpressionValue en;   
}
{     
	    en = NOTterm() 
	    (LOOKAHEAD(<FACTORIAL>) <FACTORIAL> 
	     {            
	            en = new ExpressionNode(kernel, en, ExpressionNode.FACTORIAL, null);                    
	     }      
	     )?    
	     { return en; }	    	
}

/**
 * NOTterm =  <NOT> <enelement> |
 *               	<enelement>
 */
ExpressionValue NOTterm():
{   
    ExpressionValue en;   
}
{     
	(
	    ( <NOT> | "!" ) en = enelement() 	    
	     {            
	            return new ExpressionNode(kernel, en, ExpressionNode.NOT, null);       
	     }      
	 ) 
|
	 (
	  	en = enelement() 	
	     { return en; }	    	
	 )	    	     
}

/**
 * element =    <variable>      |
 *              <float>         |
 *              ( expression )
 */
ExpressionValue enelement():
{    
    ExpressionValue ev;
    double num;
    Token c;    
}
{   
// boolean
	<TRUE>
	 { return  new MyBoolean(true); }     
|
	<FALSE>
	  { return new MyBoolean(false); }     
|	 	 
 // number
    ev = myDouble()
        { return ev; }      
|
    // cos, sin, tan, ...
    LOOKAHEAD(2147483647)
    ev = numberFunction()
         { return ev; }
|
	// command
	LOOKAHEAD(2147483647)
    ev = command()
        { return ev; } 
|
    // number or vector variable
     LOOKAHEAD(2147483647)
    ev = numVecVariable()
        { return ev; }
|        
    //list
    LOOKAHEAD(2147483647)
	ev = list()
	    { return ev; }      
| 
 // equation
    LOOKAHEAD(2147483647)
    "(" ev = equation()  ")" 
        { return ev; }       
|
    // parenthesis
    LOOKAHEAD(2147483647)
    "("  ev = expressionnode()  ")" 
        { return  ev; }       	           
|
    // cartesian vector  (x, y) or (x|y)
    LOOKAHEAD(2147483647)
    ev = cartesianvector()
        { return ev; } 
|    
    // cartesian vector  (x, y, z) or (x|y|z)
    LOOKAHEAD(2147483647)
    ev = cartesianvector3D()
        { return ev; } 
|    
    // polar vector   
    LOOKAHEAD(2147483647)
    ev = polarvector()
        { return ev; } 
 |
	// text (between " ... ")
	c = <TEXT>
    { 
    	// remove " (first and last character)
    	String text = c.image.substring(1, c.image.length()-1);
    	return  new MyStringBuffer(text);
     }  
}

ExpressionValue list():
{
    MyList myList;
    ExpressionValue ev;
}
{
   LOOKAHEAD(5)
   (
     // empty list
      "{" "}"  
      {   
           return new MyList(kernel);               
       }
    )
    |
   ( 
    // list
    "{"
      ev = cmdexpression()     
       {   
            myList = new MyList(kernel);         
            myList.addListElement(ev);
        }
       ( <COMMA> ev = cmdexpression()  
       	 {
       		myList.addListElement(ev); 
       	 } 
        )*
    "}"
    {  return myList;  }
   )          
    
}

ExpressionValue numVecVariable():
{
    GeoElement geo;
    Token c;
    ExpressionValue ev;
}
{
    c = <VARX>  
    {
        if (GeoGebraCASParsing)
 			return new ExpressionNode(kernel, new Variable(kernel, c.image));
		else
        	return new Polynomial(kernel, c.image);
    }
|
    c = <VARY>  
    {
        if (GeoGebraCASParsing)
 			return new ExpressionNode(kernel, new Variable(kernel, c.image));
		else
        	return new Polynomial(kernel, c.image);
    }
|
    c = <VARZ>  
    {
        if (GeoGebraCASParsing)
 			return new ExpressionNode(kernel, new Variable(kernel, c.image));
		else
        	return new Polynomial(kernel, c.image);
    }
|
	// spreadsheet range like A1:B2
	LOOKAHEAD (3)
	ev = spreadsheetRange()
	{
		return ev;
	}
|
    ( c = <SPREADSHEET_LABEL> | c = <LABEL> )
    {   
    	// standard case for variable
        return new ExpressionNode(kernel, new Variable(kernel, c.image));
    }
}


/**
 * spreadsheet range, e.g. A3:B5
 */
Command spreadsheetRange():
{
    Token c, c2;
}
{
	// spreadsheet range like A1:B2
	c = <SPREADSHEET_LABEL> ":" c2 = <SPREADSHEET_LABEL>
	{
		// build command CellRange[ startCell, endCell ]
		ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, c.image));
		ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, c2.image));
		Command cmd = new Command(kernel, "CellRange", false ); // don't translate name
		cmd.addArgument(startCell);
		cmd.addArgument(endCell);
		return cmd;
	}
}
   

/**
 * floating point number: angle or numeric are distinguished
 */
ExpressionValue myDouble():
{
    Token c;
    MyDouble d;
    double val;
}
{       
   (
     (c = <FLOAT> | c = <EFLOAT>)
    	{
			// check if token includes "b"
    	  
    	    c.image = c.image.replaceFirst("e", "E" );
    		val = MyDouble.parseDouble( c.image );
    	}
    |
      (c = <PERCENTAGE>) 
  		{
    		val = MyDouble.parsePercentage( c.image );
    	}
   )
  {
    	if (ExternalCASParsing || GeoGebraCASParsing) {
    		// preserve string from MathPiper: it may have higher
    		// precision than double
    	   	return new MySpecialDouble(kernel, val, c.image);  
    	}
    	else {
      	  return new MyDouble(kernel, val);
    	}                               
    }
|
    <DEGREE>
    {  // constant for degree to radians 
        d = new MySpecialDouble(kernel, Math.PI / 180.0d, "\u00b0");
        d.setAngle();
        return d;
    }
|
    <RAD>
    {  // constant for radians to radians 
        d = new MySpecialDouble(kernel, 1.0d, "rad");
        d.setAngle();
        return d;
    }
|
    <PI>
    {
       	return new MySpecialDouble(kernel, Math.PI, Unicode.PI_STRING);
    }
|
    <E>
    {
    	return new MySpecialDouble(kernel, Math.E, Unicode.EULER_STRING);
    }
 |
    <INFINITY>
    {
        return new MyDouble(kernel, Double.POSITIVE_INFINITY);
    }   
|
    <MINUS_INFINITY>
    {
        return new MyDouble(kernel, Double.NEGATIVE_INFINITY);
    }   
|
	<UNDEFINED>
	{
        return new MyDouble(kernel, Double.NaN);
    }
}


/**
 * mathematical Function (cos, sin, tan, ...)
 */
ExpressionNode numberFunction():
{
    ExpressionNode en, en2;
    ExpressionValue ev;
    MyList myList;
    Token c;
}
{           
    <X_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.XCOORD, null); }  
|
     <Y_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.YCOORD, null); }  
|
     <Z_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ZCOORD, null); }  
|
     <COS_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.COS, null); }   
|
    ( c = <COSN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.COS); }  
|
    <SIN_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SIN, null); }   
|
    ( c = <SINN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.SIN); }  
|
    <TAN_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.TAN, null); }  
|
    ( c = <TANN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.TAN); }  
|
    <CSC_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.CSC, null); }   
|
    ( c = <CSCN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.CSC); }  
|
    <SEC_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SEC, null); }  
|
    ( c = <SECN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.SEC); }  
|
    <COT_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.COT, null); }  
|
    ( c = <COTN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.COT); }  
|
    <CSCH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.CSCH, null); }   
|
    ( c = <CSCHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.CSCH); }  
|
    <SECH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SECH, null); }  
|
    ( c = <SECHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.SECH); }  
|
    <COTH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.COTH, null); }  
|
    ( c = <COTHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.COTH); }  
|
    <ACOS_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ARCCOS, null); }   
|
    <ASIN_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ARCSIN, null); }  
|
    <ATAN_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ARCTAN, null); }  
|
    <ATAN2_FUNC> ( en = expressionOrEquation() ) < COMMA > ( en2 = expressionOrEquation() ) ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ARCTAN2, en2); }  
|
    <COSH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.COSH, null); }   
|
    ( c = <COSHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.COSH); }  
|
    <SINH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SINH, null); }  
|
    ( c = <SINHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.SINH); }  
|
    <TANH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.TANH, null); }  
|
    ( c = <TANHN_FUNC> ) en = expressionOrEquation() ")"
      { return kernel.handleTrigPower(c.image, en, ExpressionNode.TANH); }  
|
    <ACOSH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ACOSH, null); }   
|
    <ASINH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ASINH, null); }  
|
    <ATANH_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ATANH, null); }  
|
    <EXP_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.EXP, null); }  
|
	LOOKAHEAD (2147483647)
    <LOG_FUNC> ( en = expressionOrEquation() ) < COMMA > ( en2 = expressionOrEquation() ) ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.LOGB, en2); }
| 
    <LOG_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.LOG, null); }
|
 	<LG_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.LOG10, null); }  
|
 	<LD_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.LOG2, null); }  
|
    <SQRT_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SQRT, null); }  
|
    <CBRT_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.CBRT, null); }  
|
    <ABS_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ABS, null); }   
|
    <SGN_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.SGN, null); }
|
    <FLOOR_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.FLOOR, null); }         
|
    <CEIL_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.CEIL, null); }               
| 
    <CONJUGATE_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.CONJUGATE, null); }               
| 
    <ARG_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ARG, null); }               
| 
    <ROUND_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.ROUND, null); }               
| 
    <GAMMA_FUNC> en = expressionOrEquation() ")"
      { return new ExpressionNode(kernel, en, ExpressionNode.GAMMA, null); }               
| 
  <RANDOM_FUNC>
      {  
      	 Construction cons = kernel.getConstruction();
      	 GeoNumeric randNum = new GeoNumeric(cons);
         cons.addRandomGeo(randNum);
         randNum.setValue(Math.random());         
      	 return new ExpressionNode(kernel, randNum, ExpressionNode.RANDOM, null);
      }
|
	(	  c = <FUNCTION_LABEL> en = expressionnode()
		{   
            myList = new MyList(kernel);         
            myList.addListElement(en);
        }
       ( <COMMA> en = expressionnode()  
       	 {
       		myList.addListElement(en); 
       	 } 
        )*
    )
	")"
	// note: the last character of FUNCTION_LABEL is a "("
      { 
      		// remove the opening parenthesis
      		String funcName = c.image.substring(0, c.image.length()-1);
      		int order = 0;
      		int index = funcName.length()-1;
      		GeoElement geo = null;    
      		String label = null;  
      		while (index >= 0) {
      			label = funcName.substring(0, index+1);
      			geo = kernel.lookupLabel(label);
      			if (geo != null) break;
      			if (c.image.charAt(index) == '\'') {
      				order++;
      				index--;
      			} else break;
      		}      		      	
      		if (geo == null) {
      				// function name does not exist: return command
      				Command cmd = new Command(kernel, funcName, true );
      				for (int i=0; i < myList.size(); i++)      				{
      				  cmd.addArgument( (ExpressionNode) myList.getListElement(i) );      				}
      				return new ExpressionNode(kernel, cmd);      						
      			
//      		  	String [] str = { "UndefinedVariable", funcName };
//           	 	throw new MyParseError(app, str);    
           	}
           	
			// create variable object for label to make sure
			// to handle lables like $A$1 correctly and keep the expression
			Variable geoVar = new Variable(kernel, label);
			ExpressionValue geoExp = geoVar.resolveAsExpressionValue();

			// numer of arguments
			int argNumber = myList.size();
      		
      		if (order > 0) { // derivative
      			if (geo.isGeoFunction()) {// function 
      				// n-th derivative of geo
	      			ExpressionNode derivative =  new ExpressionNode(kernel, geoExp, ExpressionNode.DERIVATIVE, 
	      																new MyDouble(kernel, order));
	      			return new ExpressionNode(kernel, derivative, ExpressionNode.FUNCTION, myList.getListElement(0)); 
	      		} 	      		
	      		else {
	                String [] str = { "FunctionExpected", funcName };
	                throw new MyParseError(app, str);
	      		} 		
      		}
      		else { // no derivative
	      		if (geo instanceof Evaluatable) // function 
	      			return new ExpressionNode(kernel, geoExp, ExpressionNode.FUNCTION, myList.getListElement(0)); 
				else if (geo instanceof GeoFunctionNVar) {
				  return new ExpressionNode(kernel, geoExp, ExpressionNode.FUNCTION_NVAR, myList);				}
	      		else if (geo.isGeoCurveCartesian()) // vector function 
	      			return new ExpressionNode(kernel, geoExp, ExpressionNode.VEC_FUNCTION, myList); 
	      		else if (geo.isGeoList()) // list1(1) to get first element of list1
	      			return new ExpressionNode(kernel, geoExp, ExpressionNode.ELEMENT_OF, myList); 
	      		else {// error: no function
	      			String [] str = { "FunctionExpected", funcName };
	                throw new MyParseError(app, str);
	            }
	      	}
      }  
}


/**
 * cartesianvector =  ( expression, expression ) 
 */
VectorValue cartesianvector():
{     
    ExpressionValue x, y;                
}
{   
    // cartesian coordinates
  
    (  LOOKAHEAD(2147483647)
   ( "(" x = expression() <COMMA> y = expression() ")"  ) 	
    | 
    (  "(" x = expression() <VERTICAL_BAR> y = expression() ")" )
    )
        {  return new MyVecNode(kernel, x, y); }           
}

/**
 * cartesianvector3D =  ( expression, expression ) 
 */
Vector3DValue cartesianvector3D():
{     
    ExpressionValue x, y, z;                
}
{   
    // cartesian coordinates
  
    (  LOOKAHEAD(2147483647)
   ( "(" x = expression() <COMMA> y = expression() <COMMA> z = expression() ")"  ) 	
    | 
    (  "(" x = expression() <VERTICAL_BAR> y = expression() <VERTICAL_BAR> z = expression() ")" )
    )
        {  return new MyVec3DNode(kernel, x, y, z); }           
}

/**
 * polarvector = ( expression ; expression )             
 */
VectorValue polarvector():
{     
    ExpressionValue r, phi;                  
    MyVecNode v;
}
{   
    (  
       "(" r = expression() ";"  phi = expression() ")"   
        {                            
             v = new MyVecNode(kernel);                         
             v.setPolarCoords(r, phi);     
             return v;
        }  
    )         
}

/**
 * cartesianvector_special =  <LABEL>( expression | expression ) 
 */
ExpressionNode cartesianvector_special():
{     
   Token l;
    ExpressionValue x, y;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  x = expression() <VERTICAL_BAR> y = expression() ")" )
        {         
        	ExpressionNode en =  new ExpressionNode(kernel, new MyVecNode(kernel, x, y)); 
        	en.setLabel(l.image.substring(0,l.image.length()-1));
        	return en;
        }           
}

/**
 * polarvector_special =  <LABEL>( expression ; expression ) 
 */
ExpressionNode polarvector_special():
{     
   Token l;
    ExpressionValue r, phi;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  r = expression() ";" phi = expression() ")" )
        {         
            MyVecNode v = new MyVecNode(kernel);
            v.setPolarCoords(r, phi);
        	ExpressionNode en =  new ExpressionNode(kernel, v); 
        	en.setLabel(l.image.substring(0,l.image.length()-1));
        	return en;
        }           
}