####
# Command translation table from GeoGebra to MPReduce
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=abs(%0)
Argument.1=atan2(repart(%0),impart(%0))

Binomial.2=binomial(%0,%1)
#BinomialDist.4
Cauchy.3=1/2+1/pi*atan(((%2)-(%1))/(%0))
Ceil.1=ceiling(%0)
CFactor.1=<<on factor, complex$ part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*>>
CFactor.2=<<on factor, complex$ part(!*hold(for each x in factorize(%0,%1) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*>>
ChiSquared.2=igamma((%0)/2,(%1)/2)/gamma((%0)/2)
Coefficients.1=reverse(coeff(%0,x))
CommonDenominator.2=<<off rounded$ if fixp(num(%0)) and fixp(num(%1)) then lcm(den(%0),den(%1)) else ?>>
Complex.2=%0+i*(%1)
ComplexPolar.2=complexpolar(%0,%1)
ComplexRoot.1=<<on complex$ mysolve(%0,x)>>
Conjugate.1=conj(%0)
Covariance.2=<<begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(%0,i) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(%1,i)$  return 1/tmplength*for i:=1:tmplength sum (part(%0,i)-tmpmean1)*(part(%1,i)-tmpmean2) end>>
Covariance.1=<<begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),1) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),2)$ return 1/tmplength*for i:=1:tmplength sum (part(part(%0,i),1)-tmpmean1)*(part(part(%0,i),2)-tmpmean2) end>>
Cross.2=<<matrix matrixtemp1,matrixtemp2; matrixtemp1:=%0; matrixtemp2=%1;mat((matrixtemp1(1)*matrixtemp2(2)-matrixtemp1(2)*matrixtemp2(1)),(matrixtemp1(2)*matrixtemp2(0)-matrixtemp1(0)*matrixtemp2(2)),(matrixtemp1(0)*matrixtemp2(1)-matrixtemp1(1)*matrixtemp2(0)))>>
CSolutions.1=<<on complex$ map(rhs,mycsolve(%0,ggbcasvarx))>>
CSolutions.2=<<on complex$ map(rhs,mycsolve(%0,%1))>>
CSolve.1=<<on complex$ mycsolve(%0,ggbcasvarx)>>
CSolve.2=<<on complex$ mycsolve(%0,%1)>>


Decimal.1=<<on rounded$ (%0)>>
Degree.1=deg(%0,x)
Delete.1= clear %0
Denominator.1=den(%0)
Derivative.1=df(%0,x)
Derivative.2=df(%0,%1)
Derivative.3=df(%0,%1,%2)
Determinant.1=<<tmpmat!°:=%0; det(tmpmat!°)>>
Dimension.1=length(%0)
Div.2=div(%0,%1)
Division.2=list(round((%0)/(%1)),(%0)-(%1)*round((%0)/(%1)))
Divisors.1=if numberp(%0) then if for each i in map(part(~w,2)+1,factorize(%0)) product i else '?
DivisorsList.1=if numberp(%0) then <<begin scalar divlist!°, return!°; divlist!°:=for each x in factorize(%0) collect for i:=0:part(x,2) collect part(x,1)^i; return!°:=part(divlist!°,1); for i:=2:length(divlist!°) do return!°:=for each x in part(divlist!°,i) join for each y in return!° collect x*y; return algsort(return!°,<) end>> else '?
DivisorsSum.1=if numberp(%0) then for each x in factorize(%0) product (part(x,1)^(part(x,2)+1)-1)/(part(x,1)-1) else '?
Dot.2=dot(%0,%1)

Element.2=part(%0,%1)
Element.3=for i:=%1:%2 collect part(%0,i)
Expand.1=<<off factor, pri$ on div$ %0>>
ExpandComplex.1=<<off factor, pri$ on div, complex$ %0>>
Exponential.2=1-exp(-(%0)*(%1))
Evaluate.1=%0

Factor.1=part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*
Factor.2=part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*
Factors.1=<<off complex, rounded; for each x in factorize(%0) collect if arglength(x)<0 or part(x,0) neq 'list then x:=list(x,1) else x >>
FDistribution.3=betaRegularized((%0)/2,(%1)/2,(%0)*(%2)/((%0)*(%2)+%1))
First.1=first(%0)
First.2=for i:=1:%1 collect part(%0,i)
Floor.1=floor(%0)
FractionalPart.1=if (%0)>0 then %0-floor(%0) else %0-ceiling(%0)

#These implementations follow the one in GeoGebra
FitExp.1=<<on rounded, roundall, numval; begin scalar p1!°, p2!°, input!°, sigmax!°, sigmay!°, sigmaxy!°, sigmax2!°, length!°, denominator!°, xlist!°, ylist!°; input!°:=%0; xlist!°:=map(part(~w!°,1), input!°); ylist!°:=map(log,map(part(~w!°,2), input!°)); length!°:=length(ylist!°); sigmax!°:=for each i in xlist!° sum i; sigmay!°:= for each i in ylist!° sum i; sigmax2!°:= for each i in xlist!° sum i^2; sigmaxy!°:=for i:=1:length!° sum part(xlist!°,i)*part(ylist!°,i);denominator!°:= length!°*sigmax2!°-sigmax!°**2; p2!°:=(length!°*sigmaxy!°-sigmax!°*sigmay!°)/denominator!°; p1!°:= exp((sigmay!°*sigmax2!°-sigmax!°*sigmaxy!°)/denominator!°); return p1!°*exp(x*p2!°) end>>
FitLog.1=<<on rounded, roundall, numval; begin scalar p1!°, p2!°, input!°, sigmax!°, sigmay!°, sigmaxy!°, sigmax2!°, length!°, denominator!°, xlist!°, ylist!°; input!°:=%0; xlist!°:=map(log,map(part(~w!°,1), input!°)); ylist!°:=map(part(~w!°,2), input!°); length!°:=length(ylist!°); sigmax!°:=for each i in xlist!° sum i; sigmay!°:= for each i in ylist!° sum i; sigmax2!°:= for each i in xlist!° sum i^2; sigmaxy!°:=for i:=1:length!° sum part(xlist!°,i)*part(ylist!°,i);denominator!°:= length!°*sigmax2!°-sigmax!°**2; p2!°:=(length!°*sigmaxy!°-sigmax!°*sigmay!°)/denominator!°; p1!°:= (sigmay!°*sigmax2!°-sigmax!°*sigmaxy!°)/denominator!°; return p1!°+log(x)*p2!° end >>
FitPoly.2=<< clear tmpx!°, tmpy!°; on rounded, roundall, numval; begin scalar xvec!°, yvec!°, input!°; input!°:= %0; xvec!°:=map(part(~w!°,1), input!°); yvec!°:= map(part(~w!°,2), input!°); tmpx!°:=vandermonde(xvec!°); tmpx!°:=sub\\_matrix(tmpx!°,for i:=1:length(input!°) collect i, for i:=1:(%1+1) collect i); tmpy!°:=listtocolumnvector(yvec!°);tmpx!°:=(1/(tp(tmpx!°)*tmpx!°))*tp(tmpx!°); tmpy!°:=tmpx!°*tmpy!°; return for i:=1:part(length(tmpy!°),1) sum tmpy!°(i,1)*x^(i-1) end>>
FitPow.1=<<on rounded, roundall, numval; begin scalar p1!°, p2!°, input!°, sigmax!°, sigmay!°, sigmaxy!°, sigmax2!°, length!°, denominator!°, xlist!°, ylist!°; input!°:=%0; xlist!°:=map(log,map(part(~w!°,1), input!°)); ylist!°:=map(log,map(part(~w!°,2), input!°)); length!°:=length(ylist!°); sigmax!°:=for each i in xlist!° sum i; sigmay!°:= for each i in ylist!° sum i; sigmax2!°:= for each i in xlist!° sum i^2; sigmaxy!°:=for i:=1:length!° sum part(xlist!°,i)*part(ylist!°,i);denominator!°:= length!°*sigmax2!°-sigmax!°**2; p2!°:=(length!°*sigmaxy!°-sigmax!°*sigmay!°)/denominator!°; p1!°:= exp((sigmay!°*sigmax2!°-sigmax!°*sigmaxy!°)/denominator!°); return p1!°*x^p2!° end >>
#FitSin

Gamma.3=(((%1)*(%2))^(%0))/(%0)*kummerm(%0,%0+1,-(%1)*(%2))/beta(%0)
GCD.2=gcd(%0,%1)
GCD.1=<<begin scalar gcd!°; gcd!°:=0; for each term in (%0) do gcd!°:=gcd(gcd!°,term); return gcd!° end >>
#GetPrecision.1

HCF.2=gcd(%0,%1)
HyperGeometric.5=<<begin scalar m,kk,ng,n; m:=%1$ ng:=%0$ n:=%2$ kk:=%3$ return if %4=true then sum(binomial(m,k)*binomial((ng-m),(n-k))/binomial(ng,n),k,0,kk) else binomial(m,kk)*binomial((ng-m),(n-kk))/binomial(ng,n) end>>

Identity.1=make\\_identity(%0)
If.2=if %0 then <<%1>>
If.3=if %0 then <<%1>> else <<%2>>
Imaginary.1=impart(%0)
ImplicitDerivative.3=-df(%0,%1)/df(%0,%2)
Integral.1=<<begin scalar integral!°; integral!°:=int(%0,ggbcasvarx); return if freeof(integral!°,'int) then integral!° else '? end>>
Integral.2=<<begin scalar integral!°; integral!°:=int(%0,%1); return if freeof(integral!°,'int) then integral!° else '? end>>
Integral.4=if numeric!°=0 then <<begin scalar integral!°; integral!°:=int(%0,%1,%2,%3); return if freeof(integral!°,'int) then integral!° else '? end>> else num\\_int(%0,%1=(%2 .. %3))
IntegralBetween.4=if numeric!°=0 then <<begin scalar integral!°; integral!°:=int(%0-(%1),ggbcasvarx,%2,%3); return if freeof(integral!°,'int) then integral!° else '? end>> else num\\_int(%0,%1=(%2 .. %3))
IntegralBetween.5=if numeric!°=0 then <<begin scalar integral!°; integral!°:=int(%0-(%1),%2,%3,%4); return if freeof(integral!°,'int) then integral!° else '? end>> else num\\_int(%0,%1=(%2 .. %3))
Intersect.2=<<begin scalar eqn1!°, eqn2!°; eqn1!°:=%0; eqn2!°:=%1; if freeof(eqn1!°,=) then eqn1!°:= eqn1!°=y; if freeof(eqn2!°,=) then eqn2!°:= eqn2!°=y; return mysolve(list(eqn1!°,eqn2!°),list(ggbcasvarx,ggbcasvary)) end>>
Invert.1=1/(%0)
IntegerPart.1=if %0>0 then floor(%0) else ceiling(%0)
IsPrime.1=if primep(%0) then true else false
IsBound.1=if << symbolic; p!°:=isbound!°('%0); algebraic; p!°>>=1 then 'true else 'false

#KeepInput.1=

Last.1=last(%0)
Last.2=for i:=1:%1 collect part(%0,length(%0)-i)
LCM.1=<<begin scalar lcm!°; lcm!°:=0; for each term in (%0) do lcm!°:=lcm(lcm!°,term); return lcm!° end >>
LCM.2=lcm(%0,%1)
Ld.1=logb(%0,2)
LeftSide.1=lhs(%0)
Length.3=int(sqrt(1+df(%0,ggbcasvarx)),ggbcasvarx,%1,%2)
Length.4=int(sqrt(1+df(%0,%1)),%1,%2,%3)
Lg.1=log10(%0)
Limit.2=limit(%0,ggbcasvarx,%1)
Limit.3=limit(%0,%1,%2)
LimitAbove.2=limit!+(%0,ggbcasvarx,%1)
LimitAbove.3=limit!+(%0,%1,%2)
LimitBelow.2=limit!-(%0,ggbcasvarx,%1)
LimitBelow.3=limit!-(%0,%1,%2)
Ln.1=log(%0)
Log.1=log10(%0)
Log.2=logb(%0,%1)

Max.N=max(%)
MatrixRank.1=rank(%0)
Mean.1=<<begin scalar list!°; list!°:=%0$ return 1/length(list!°)*for i:=1:length(list!°) sum part(list!°,i) end>>
Median.1=<<begin scalar list!°; list!°:=%0$ list!°:= sortnumlist list!°$ return if remainder(length(list!°),2)=0 then (part(list!°,length(list!°)/2)+part(list!°,1+length(list!°)/2))/2 else part(list!°,(length(list!°)+1)/2) end>>
Min.N=min(%)
Mod.2=mod!°(%0,%1)

NextPrime.1=nextprime(%0)
NIntegral.3=<<on numval, roundall$ num\\_int(%0,ggbcasvarx=((%1) .. (%2))) >>
NIntegral.4=<<on numval, roundall$ num\\_int(%0,%1=((%2) .. (%3))) >>
Normal.3=1/2*(1+erf((%2-(%0))/sqrt(2*(%1)^2)))
nPr.2=factorial(floor(%0))/factorial(floor(%0-%1))
NRoot.2=(%0)^(1/(%1))
NSolve.1=<<on rounded, numval, roundall$ num\\_solve(%0,ggbcasvarx) >>
NSolve.2=<<on rounded, numval, roundall$ num\\_solve(%0,%1) >>
NRoots.1=<<on rounded, numval, roundall$ num\\_solve(%0,ggbcasvarx) >>
NSolutions.1=<<on rounded, numval, roundall$ map(rhs,num\\_solve(%0,ggbcasvarx)) >>
Numerator.1=num(%0)
Numeric.1=<<numeric!°:=1; on rounded, roundall, numval$ %0>>
Numeric.2=<<numeric!°:=1; on rounded, roundall, numval$ if %1<=16 then <<print\\_precision(%1)$ %0>> else <<precision(%1)$ print\\_precision(%1)$ %0 >> >>
N.1=<<numeric!°:=1; on rounded, roundall, numval$ %0>>
N.2=<<numeric!°:=1; on rounded, roundall, numval$ if %1<=16 then <<print\\_precision(%1)$ %0>> else <<precision(%1)$ print\\_precision(%1)$ %0 >> >>

OrthogonalVector.1=if arglength(%0)>-1 and part(%0,0)='list then list(-part(%0,2),part(%0,1)) else mat((0,-1),(1,0))*(%0)

PartialFractions.1=part(pf(%0,ggbcasvarx),0):=+
Pascal.4=if %3=true then betaRegularized(%0,1+floor(%2),%1) else (1-(%1))^(%2)*(%1)^(%0)*binomial(%0+%2-1,%0-1)
Poisson.3=if %2=true then exp(-(%0))*for i:=0:(%1) sum (%0)^i/factorial(floor(i)) else (%0)^(%1)/factorial(floor(%1))*exp(-%0)
PreviousPrime.1=<<begin scalar tmp!°; tmp!°:=%0-1; while not(primep(tmp!°)) and not(tmp!°<3) do tmp!°:=tmp!°-1; return if primep(tmp!°) then tmp!° else ? end>>
PrimeFactors.1=<<off rounded; begin scalar factorlist!°; factorlist!°:=factorize(%0); factorlist!°:= for each x!° in factorlist!° collect for i:=1:part(x!°,2) collect part(x!°,1); return mkdepth\\_one(factorlist!°) end>>
Product.1=for i:=1:length(%0) product part(%0,i)
Product.4=prod(%0,%1,%2,%3)
Prog.1=<<%0>>
Prog.2=<<begin scalar %0; return %1 end>>
ProperFraction.1=<<begin scalar result!°; result!°:=list(if %0>0 then floor(%0) else ceiling(%0),if (%0)>0 then %0-floor(%0) else %0-ceiling(%0)); return if part(result!°,2)=0 then part(result!°,1) else part(result!°,0):=+ end>>

Random.2=random(%1-%0+1)+%0
RandomBinomial.2=<<on rounded, roundall, numval; for each x in for i:=1:%0 collect random(10000000)/10000000 sum if (x<%1) then 1 else 0 >>
RandomElement.1=part(%0,random(length(%0))+1)
RandomPoisson.1=<<on rounded, roundall, numval; -log(random(10000000)/10000000)/(%0)>>
RandomNormal.2=<<on rounded, roundall, numval; %0+(%1)*cos(2*pi*random(10000000)/10000000)*sqrt(-2*log(random(10000000)/10000000)) >>
RandomPolynomial.3=randpoly(ggbcasvarx, maxdeg=%0, coeffs=rand(%1 .. %2))
RandomPolynomial.4=randpoly(%0, maxdeg=%1, coeffs=rand(%2 .. %3))
Rationalize.1=<<off rounded; %0 >>
Real.1=repart(%0)
RightSide.1=rhs(%0)
Root.1=if numeric!°=0 then mysolve(%0,ggbcasvarx) else num\\_solve(%0,ggbcasvarx)
ReducedRowEchelonForm.1=<<begin scalar tmpmatrix, tmpcolumn; tmpmatrix:=%0$ tmpcolumn:=1$for i:=1:row\\_dim(tmpmatrix) do <<if tmpmatrix(i,tmpcolumn)=0 then while (tmpcolumn<=column\\_dim(tmpmatrix) and tmpmatrix(i,tmpcolumn)=0 and i<=row\\_dim(tmpmatrix)) do << for j:=i+1:row\\_dim(tmpmatrix) do if (tmpmatrix(i,j) neq 0) then tmpmatrix:=swap\\_rows(tmpmatrix,tmpcolumn, j)$ if (tmpmatrix(i,tmpcolumn)=0) then tmpcolumn:=tmpcolumn+1>>$ if tmpcolumn<=column\\_dim(tmpmatrix) then if tmpmatrix(i, tmpcolumn) neq 0 then << tmpmatrix:=pivot(tmpmatrix,i,tmpcolumn); tmpmatrix:=mult\\_rows(tmpmatrix,i,1/tmpmatrix(i,tmpcolumn))$ tmpcolumn:=tmpcolumn+1; >> >>$ return tmpmatrix end>>

Sample.2=for i:=1:%1 collect part(%0,1+random(length(%0)))
Sample.3=<< begin scalar list!°; list!°:=%0; return if %2=true then for i:=1:%1 collect part(list!°,1+random(length(list!°))) else for i:=1:%1 collect(part(num\\_to\\_perm(1+random(myfactorial(length(list!°))),list!°),i) end >>
SampleVariance.1=<< begin scalar n!°, list!°; list!°:=%0; n!°:=length(%0); return 1/(n!°-1)*(for each i in list!° sum i^2)-1/(n!°^2-n!°)*(for each i in list!° sum i)^2 end >>
SampleSD.1=<< begin scalar n!°, list!°; list!°:=%0; n!°:=length(%0); return sqrt(1/(n!°-1)*(for each i in list!° sum i^2)-1/(n!°^2-n!°)*(for each i in list!° sum i)^2) end >>
Sequence.1=for i:=1:(%0) collect i
Sequence.4=<<begin scalar %1; return for %1:=(%2):(%3) collect (%0) end>>
Sequence.5=<<begin scalar %1; return for %1:=(%2) step (%4) until (%3) collect (%0) end>>
SetPrecision.1=<<printprecision!°:=%0; print\\_precision printprecision!°>>
SetPrecision.2=<<precision!°:=%0; precision precision!°>>
SD.1=<<begin scalar tmpmean, tmplist; tmplist:=%0$ tmpmean:=0$ tmpmean:= (1/length(tmplist))*for i:=1:length(tmplist) sum part(tmplist,i)$ return sqrt((1/length(tmplist))*for i:=1:length(tmplist) sum (part(tmplist,i)^2-tmpmean^2)) end>>
Shuffle.1=<<begin scalar tmpret; tmpret:=(%0)$ return num\\_to\\_perm(random(length(tmpret)),tmpret) end>>
Sign.1=sign(%0)
Simplify.1=%0
SimplifyFull.1=simplify(%0)
Solutions.1=map(rhs,mysolve(%0,ggbcasvarx))
Solutions.2=map(rhs,mysolve(%0,%1))
Solve.1=mysolve(%0,ggbcasvarx)
Solve.2=<< begin scalar equations!°; equations!°:=%0; if arglength(equations!°)>-1 and part(equations!°,0)='list then equations!°:=mkdepthone(equations!°); return mysolve(equations!°,%1) end >>
SolveODE.1=<<begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(ggbcasvary,ggbcasvarx)=tmpeqn,ggbcasvary,ggbcasvarx) else tmpret:=odesolve(tmpeqn,ggbcasvary,ggbcasvarx)$ return if length(tmpret)=1 then first(tmpret) else tmpret end>>
SolveODE.3=begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(%1,%2)=tmpeqn,%1,%2) else tmpret:=odesolve(tmpeqn,%1,%2)$ return if length(tmpret)=1 then first(tmpret) else tmpret end
Sqrt.1=sqrt(%0)
#Substitute.2=if hold!°=0 then sub(%1,%0) else sub(%1, !*hold(%0))
#Substitute.3=if hold!°=0 then sub(%1=%2,%0) else sub(%1=%2,!*hold(%0))
Substitute.3=sub(%1=%2,%0)
#SubstituteParallel.2=if hold!°=0 then sub(%1,%0) else sub(%1,!*hold(%0))
SubstituteHold.2=sub(%1, !*hold(%0))
Sum.1=for i:=1:length(%0) sum part(%0,i)
Sum.4=sum(%0,%1,%2,%3)

Take.3=<<begin scalar tmpret; tmpret:=list()$ for i:=%1:%2 do tmpret:=part(%0,i).tmpret$ return reverse(tmpret) end>>
TaylorSeries.3=<<on div$ off pri$ taylortostandard(taylor(%0,ggbcasvarx,%1,%2))>>
TaylorSeries.4=<<on div$ off pri$ taylortostandard(taylor(%0,%1,%2,%3))>>
TDistribution.2=<<begin scalar t,n; n!°:=%0; t!°:=%1 ;beta!Regularized(((t!°+sqrt(t!°^2+n!°)/(2*sqrt(t!°^2+n!°)),n!°/2,n!°/2)
ToBinomial.1=%0
ToPolar.1=part(list(sqrt(repart(%0)^2+impart(%0)^2),atan2(repart(%0),impart(%0))),0):=complexpolar
ToExponential.1=part(list(sqrt(repart(%0)^2+impart(%0)^2),part(list(i*atan2(repart(%0),impart(%0))),0):=exp),0):=*
Transpose.1=tp(%0)

Unique.1=mkset(%0)
UnitOrthogonalVector.1=<<begin; clear mat!°,norm!°; input!°:=%0;return if arglength(input!°)>-1 and part(input!°,0)='list then <<norm!°:=sqrt(<<for each i in input!° sum i^2>>); list(-part(input!°,2)/norm!°,part(input!°,1)/norm!°) >> else <<norm!°:=sqrt(<<for i:=1:row\\_dim(input!°) sum input!°(i,1)^2>>); norm!°*mat((0,-1),(1,0))*input!° >> end >>
UnitVector.1=<<begin; clear input!°; input!°:=%0; return if arglength(input!°)>-1 and part(input!°,0)='list then map(~w/sqrt(<<for each i in input!° sum i^2>>),input!°) else input!°/sqrt(<<for i:=1:row\\_dim(input!°) sum input!°(i,1)^2>>) end>>

Variance.1=<<begin scalar x!°,n!°,xd!°; x!°:=%0$ n!°:=length(x!°)$ xd!°:=1/n!°*for each i in x!° sum i; return 1/n!°* for each i in x!° sum (i-xd!°)**2 end>>

Weibull.3=1-exp(-(%0)*(%2)^(%1))

Zipf.4=<<begin scalar s; s:= %1; return if %3=true then harmonic(%2,s)/harmonic(%0,s) else 1/((%2)^s*harmonic(%0,s)) end>>