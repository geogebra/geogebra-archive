####
# Command translation table from GeoGebra to MPReduce
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=abs(%0)
Argument.1=atan2(repart(%0),impart(%0))

Binomial.2=binomial(%0,%1)
Cauchy.3=1/2+1/pi*atan(((%2)-(%1))/(%0))
Ceil.1=ceiling(%0);
CFactor.1=<<on factor, complex$ %0>>
CFactor.2=<<on factor, complex$ factor(%1)$ %0>>
ChiSquared.2=igamma((%0)/2,(%1)/2)/gamma((%0)/2)
Coefficients.1=reverse(coeff(%0,x))
CommonDenominator.2=<<off rounded$ if fixp(num(%0)) and fixp(num(%1)) then lcm(den(%0),den(%1)) else ?>>
Complex.2=%0+i*(%1)
#ComplexPolar.2
ComplexRoot.1=<<on complex$ solve(%0,x)>>
Conjugate.1=conj(%0)
Covariance.2=begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(%0,i) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(%1,i)$  return 1/tmplength*for i:=1:tmplength sum (part(%0,i)-tmpmean1)*(part(%1,i)-tmpmean2) end
Covariance.1=begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),1) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),2)$ return 1/tmplength*for i:=1:tmplength sum (part(part(%0,i),1)-tmpmean1)*(part(part(%0,i),2)-tmpmean2) end
Cross.2=<<matrix matrixtemp1,matrixtemp2; matrixtemp1:=%0; matrixtemp2=%1;mat((matrixtemp1(1)*matrixtemp2(2)-matrixtemp1(2)*matrixtemp2(1)),(matrixtemp1(2)*matrixtemp2(0)-matrixtemp1(0)*matrixtemp2(2)),(matrixtemp1(0)*matrixtemp2(1)-matrixtemp1(1)*matrixtemp2(0)))>>
CSolutions.1=<<on complex$ map(rhs,solve(%0,x))>>
CSolutions.2=<<on complex$ map(rhs,solve(%0,%1))>>
CSolve.1=<<on complex$ solve(%0)>>
CSolve.2=<<on complex$ solve(%0,%1)>>


Decimal.1=<<on rounded$ (%0)>>
Degree.1=deg(%0,x)
Delete.1= clear %0
Denominator.1=den(%0)
Derivative.1=df(%0,x)
Derivative.2=df(%0,%1)
Derivative.3=df(%0,%1,%2)
Determinant.1=det(%0)
Dimension.1=length(%0)
Div.2=round((%0)/(%1))
Division.2={round((%0)/(%1)),(%0)-(%1)*round((%0)/(%1))}
Divisors.1=for i:=1:%0 sum if remainder(%0,i)=0 then 1 else 0
DivisorsList.1=for i:=1:%0 join if remainder(%0,i)=0 then {i} else {}
DivisorsSum.1=for i:=1:%0 sum if remainder(%0,i)=0 then i else 0
Dot.2=dot(%0,%1)

Element.2=part(%0,%1)
Element.3=for i:=%1:%2 collect part(%0,i)
Expand.1=<<off factor$ %0>>
#ExpandComplex.1
#Exponential.2

Factor.1=<<on factor$ %0>>
FDistribution.3=ibeta((%0)/2,(%1)/2,(%0)*(%2)/((%0)*(%2)+(%1)))/beta((%0)/2,(%1)/2)
First.1=first(%0)
First.2=for i:=1:%1 collect part(%0,i)
Floor.1=floor(%0)
FractionalPart.1=if (%0)>0 then %0-floor(%0) else %0-ceiling(%0)

Gamma.3=(((%1)*(%2))^(%0))/(%0)*kummerm(%0,%0+1,-(%1)*(%2))/beta(%0)
GCD.2=gcd(%0,%1)
#GetPrecision.1

HCF.2=gcd(%0,%1)
HyperGeometric.5=<<begin scalar m,kk,ng,n; m:=%1$ ng:=%0$ n:=%2$ kk:=%3$ return if %4=true then sum(binomial(m,k)*binomial((ng-m),(n-k))/binomial(ng,n),k,0,kk) else binomial(m,kk)*binomial((ng-m),(n-kk))/binomial(ng,n) end

If.2=if boolean(%0) then <<%1>>
If.3=if boolean(%0) then <<%1>> else <<%2>>
Imaginary.1=impart(%0)
#ImplicitDerivative.3
Integral.1=int(%0,x)
Integral.2=int(%0,%1)
Integral.4=int(%0,%1,%2,%3)
#Intersect.2
Invert.1=1/(%0)
#IntegerPart.1
IsPrime.1=if primep(%0) then true else false

#KeepInput.1

Last.1=last(%0)
for i:=1:%1 collect part(%0,i)
Last.2=for i:=1:%1 collect part(%0,length(%0)-i)
LCM.2=lcm(%0,%1)
Ld.1=logb(%0,2)
LeftSide.1=lhs(%0)
Length.3=int(sqrt(1+df(%0,x)),x,%1,%2)
Length.4=int(sqrt(1+df(%0,%1)),%1,%2,%3)
Lg.1=log10(%0)
Limit.2=limit(%0,x,%1)
Limit.3=limit(%0,%1,%2)
LimitAbove.2=limit!+(%0,x,%1)
LimitAbove.3=limit!+(%0,%1,%2)
LimitBelow.2=limit!-(%0,x,%1)
LimitBelow.3=limit!-(%0,%1,%2)
Ln.1=log(%0)
Log.1=log10(%0)
Log.2=logb(%0,%1)

Max.N=max(%)
MatrixRank.1=rank(%0)
Mean.1=<<clear tmplist, tempret$ tempret:=0$ templist:=%0$ for i:=1:length(tmplist) do tempret:=tempret+part(tempret,i)$ tempret/length(templist)>>
Median.1=<<clear tmplist$ tmplist:=%0$ tmplist:= sortnumlist tmplist$ if remainder(length(tmplist),2)=0 then (part(tmplist,length(templist)/2)+part(tmplist,1+length(templist)/2))/2 else part(tmplist,(length(templist)+1)/2)>>
Min.N=min(%)
Mod.2=remainder(%0,%1)

NextPrime.1=nextprime(%0)
NIntegral.3=<<off complex$ num\\_int(%0,x=((%1) .. (%2)))>>
NIntegral.4=<<off complex$ num\\_int(%0,%1=((%2) .. (%3)))>>
#Normal.3
nPr.2=(factorial(%0)/factorial(%0-%1))
#NRoot.2
NSolve.1=num\\_solve(%0,x)
NRoots.1=num\\_solve(%0,x)
#NSolutions.1
Numerator.1=num(%0)
Numeric.1= <<on rounded$ %0>>
#Numeric.2
N.1=<<on rounded$ %0>>
#N.2

#OrthogonalVector.1

#PartialFractions.1
#Pascal.4
#PreviousPrime.1
#PrimeFactors.1
Product.1=for i:=1:length(%0) product part(%0,i)
Product.4=prod(%0,%1,%2,%3)
Prog.1=<<%0>>
Prog.2=begin scalar %0; return %1; end
#ProperFraction.1

Random.2=random(%0 .. %1)
#RandomBinomial.2
#RandomElement.1
#RandomPoisson.1
#RandomNormal.2
RandomPolynomial.3=randpoly(x, maxdeg=%0, coeffs=rand(%1 .. %2));
RandomPolynomial.4=randpoly(%0, maxdeg=%1, coeffs=rand(%2 .. %3));
Rationalize.1=<<off rounded; %0 >>
Real.1=repart(%0)
RightSide.1=rhs(%0)
Root.1=solve(%0,x)
ReducedRowEchelonForm.1=begin scalar tmpmatrix, tmpcolumn; tmpmatrix:=%0$ tmpcolumn:=1$for i:=1:row\\_dim(tmpmatrix) do <<if tmpmatrix(i,tmpcolumn)=0 then while (tmpcolumn<=column\\_dim(tmpmatrix) and tmpmatrix(i,tmpcolumn)=0 and i<=row\\_dim(tmpmatrix)) do << for j:=i+1:row\\_dim(tmpmatrix) do if (tmpmatrix(i,j) neq 0) then tmpmatrix:=swap\\_rows(tmpmatrix,tmpcolumn, j)$ if (tmpmatrix(i,tmpcolumn)=0) then tmpcolumn:=tmpcolumn+1>>$ if tmpcolumn<=column\\_dim(tmpmatrix) then if tmpmatrix(i, tmpcolumn) neq 0 then << tmpmatrix:=pivot(tmpmatrix,i,tmpcolumn); tmpmatrix:=mult\\_rows(tmpmatrix,i,1/tmpmatrix(i,tmpcolumn))$ tmpcolumn:=tmpcolumn+1; >> >>$ return tmpmatrix end

Sample.2=begin scalar tmpret; list tmpret$ tmpret:={}$ for i:=1:%1 do tmpret:=part(%0,1+random(length(%0))).tmpret$ return tmpret end
#Sample.3
#SampleVariance.1
#SampleSD.1
#Sequence.4
#Sequence.5
#SetPrecision.1
SD.1=begin scalar tmpmean, tmplist; tmplist:=%0$ tmpmean:=0$ tmpmean:= (1/length(tmplist))*for i:=1:length(tmplist) sum part(tmplist,i)$ return sqrt((1/length(tmplist))*for i:=1:length(tmplist) sum (part(tmplist,i)^2-tmpmean^2)) end
Shuffle.1=begin scalar tmpret; tmpret:=(%0)$ return num\\_to\\_perm(random(length(tmpret)),tmpret) end
Sign.1=sign(%0)
Simplify.1=%0
#SimplifyFull.1
Solutions.1=map(rhs,solve(%0,x))
Solutions.2=map(rhs,solve(%0,%1))
Solve.1=solve(%0,x)
Solve.2=solve(%0,%1)
SolveODE.1=begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(y,x)=tmpeqn,y,x) else tmpret:=odesolve(tmpeqn,y,x)$ return if length(tmpret)=1 then first(tmpret) else tmpret end
SolveODE.3=begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(%1,%2)=tmpeqn,%1,%2) else tmpret:=odesolve(tmpeqn,%1,%2)$ return if length(tmpret)=1 then first(tmpret) else tmpret end
Sqrt.1=sqrt(%0)
#Substitute.2
#Substitute.3
#SubstituteParallel.2
Sum.1=for i:=1:length(%0) sum part(%0,i)
Sum.4=sum(%0,%1,%2,%3)

Take.3=begin scalar tmpret; tmpret:={}$ for i:=%1:%2 do tmpret:=part(%0,i).tmpret$ return reverse(tmpret) end
Taylor.3=taylortostandard(taylor(%0,x,%1,%2))
Taylor.4=taylortostandard(taylor(%0,%1,%2,%3))


#TDistribution.2
#ToBinomial.1
#ToPolar.1
#ToExponential.1
Transpose.1=tp(%0)


#Unique.1
#UnitOrthogonalVector.1
UnitVector.1=begin scalar input!°;input!°:=%0; return if not numberp(input!°) and part(input!°,0)=list then map(~w/sqrt(<<for each i in input!° sum i^2>>),input!°) else input!°/sqrt(<<for i:=1:row\\_dim(input!°) sum input(1,i)^2>>) end

Variance.1=begin scalar x,n,xd; x:=%0$ n:=length(x)$ xd:=1/n*for each i in x sum i; return 1/n* for each i in x sum (i-xd)**2 end

Weibull.3=1-Exp(-(%0)*(%2)^(%1))

Zipf.4=begin scalar s; s:= %1; return if %3=true then harmonic(%2,s)/harmonic(%0,s) else 1/((%2)^s*harmonic(%0,s)) end