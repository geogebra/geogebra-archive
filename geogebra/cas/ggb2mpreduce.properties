####
# Command translation table from GeoGebra to MPReduce
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=abs(%0)
Argument.1=atan2(repart(%0),impart(%0))

Binomial.2=binomial(%0,%1)
#BinomialDist.4
Cauchy.3=1/2+1/pi*atan(((%2)-(%1))/(%0))
Ceil.1=ceiling(%0)
CFactor.1=<<on factor, complex$ part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*>>
CFactor.2=<<on factor, complex$ part(!*hold(for each x in factorize(%0,%1) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*>>
ChiSquared.2=igamma((%0)/2,(%1)/2)/gamma((%0)/2)
Coefficients.1=reverse(coeff(%0,x))
CommonDenominator.2=<<off rounded$ if fixp(num(%0)) and fixp(num(%1)) then lcm(den(%0),den(%1)) else ?>>
Complex.2=%0+i*(%1)
ComplexPolar.2=complexpolar(%0,%1)
ComplexRoot.1=<<on complex$ mysolve(%0,x)>>
Conjugate.1=conj(%0)
Covariance.2=<<begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(%0,i) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(%1,i)$  return 1/tmplength*for i:=1:tmplength sum (part(%0,i)-tmpmean1)*(part(%1,i)-tmpmean2) end>>
Covariance.1=<<begin scalar ret, tmpmean1, tmpmean2, tmplength; ret:=0$ tmpmean1:=0$ tmpmean2:=0$ tmplength:=length(%0)$ tmpmean1:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),1) $ tmpmean2:=1/tmplength*for i:=1:tmplength sum part(part(%0,i),2)$ return 1/tmplength*for i:=1:tmplength sum (part(part(%0,i),1)-tmpmean1)*(part(part(%0,i),2)-tmpmean2) end>>
Cross.2=<<matrix matrixtemp1,matrixtemp2; matrixtemp1:=%0; matrixtemp2=%1;mat((matrixtemp1(1)*matrixtemp2(2)-matrixtemp1(2)*matrixtemp2(1)),(matrixtemp1(2)*matrixtemp2(0)-matrixtemp1(0)*matrixtemp2(2)),(matrixtemp1(0)*matrixtemp2(1)-matrixtemp1(1)*matrixtemp2(0)))>>
CSolutions.1=<<on complex$ map(rhs,mycsolve(%0,ggbcasvarx))>>
CSolutions.2=<<on complex$ map(rhs,mycsolve(%0,%1))>>
CSolve.1=<<on complex$ mycsolve(%0,ggbcasvarx)>>
CSolve.2=<<on complex$ mycsolve(%0,%1)>>


Decimal.1=<<on rounded$ (%0)>>
Degree.1=deg(%0,x)
Delete.1= clear %0
Denominator.1=den(%0)
Derivative.1=df(%0,x)
Derivative.2=df(%0,%1)
Derivative.3=df(%0,%1,%2)
Determinant.1=<<tmpmat!\u00b0:=%0; det(tmpmat!\u00b0)>>
Dimension.1=length(%0)
Div.2=div(%0,%1)
Division.2=list(round((%0)/(%1)),(%0)-(%1)*round((%0)/(%1)))
Divisors.1=if numberp(%0) then if for each i in map(part(~w,2)+1,factorize(%0)) product i else '?
DivisorsList.1=if numberp(%0) then <<begin scalar divlist!\u00b0, return!\u00b0; divlist!\u00b0:=for each x in factorize(%0) collect for i:=0:part(x,2) collect part(x,1)^i; return!\u00b0:=part(divlist!\u00b0,1); for i:=2:length(divlist!\u00b0) do return!\u00b0:=for each x in part(divlist!\u00b0,i) join for each y in return!\u00b0 collect x*y; return algsort(return!\u00b0,<) end>> else '?
DivisorsSum.1=if numberp(%0) then for each x in factorize(%0) product (part(x,1)^(part(x,2)+1)-1)/(part(x,1)-1) else '?
Dot.2=dot(%0,%1)

Element.2=part(%0,%1)
Element.3=for i:=%1:%2 collect part(%0,i)
Expand.1=<<off factor, pri$ on div$ %0>>
ExpandComplex.1=<<off factor, pri$ on div, complex$ %0>>
Exponential.2=1-exp(-(%0)*(%1))
Evaluate.1=%0

Factor.1=part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*
Factor.2=part(!*hold(for each x in factorize(%0) collect (if arglength(x)<0 or part(x,0) neq 'list then x else if part(x,2)=1 then part(x,1) else part(x,0):=**)),0):=*
Factors.1=<<off complex, rounded; for each x in factorize(%0) collect if arglength(x)<0 or part(x,0) neq 'list then x:=list(x,1) else x >>
FDistribution.3=betaRegularized((%0)/2,(%1)/2,(%0)*(%2)/((%0)*(%2)+%1))
First.1=first(%0)
First.2=for i:=1:%1 collect part(%0,i)
Floor.1=floor(%0)
FractionalPart.1=if (%0)>0 then %0-floor(%0) else %0-ceiling(%0)

#These implementations follow the one in GeoGebra
FitExp.1=<<on rounded, roundall, numval; begin scalar p1!\u00b0, p2!\u00b0, input!\u00b0, sigmax!\u00b0, sigmay!\u00b0, sigmaxy!\u00b0, sigmax2!\u00b0, length!\u00b0, denominator!\u00b0, xlist!\u00b0, ylist!\u00b0; input!\u00b0:=%0; xlist!\u00b0:=map(part(~w!\u00b0,1), input!\u00b0); ylist!\u00b0:=map(log,map(part(~w!\u00b0,2), input!\u00b0)); length!\u00b0:=length(ylist!\u00b0); sigmax!\u00b0:=for each i in xlist!\u00b0 sum i; sigmay!\u00b0:= for each i in ylist!\u00b0 sum i; sigmax2!\u00b0:= for each i in xlist!\u00b0 sum i^2; sigmaxy!\u00b0:=for i:=1:length!\u00b0 sum part(xlist!\u00b0,i)*part(ylist!\u00b0,i);denominator!\u00b0:= length!\u00b0*sigmax2!\u00b0-sigmax!\u00b0**2; p2!\u00b0:=(length!\u00b0*sigmaxy!\u00b0-sigmax!\u00b0*sigmay!\u00b0)/denominator!\u00b0; p1!\u00b0:= exp((sigmay!\u00b0*sigmax2!\u00b0-sigmax!\u00b0*sigmaxy!\u00b0)/denominator!\u00b0); return p1!\u00b0*exp(x*p2!\u00b0) end>>
FitLog.1=<<on rounded, roundall, numval; begin scalar p1!\u00b0, p2!\u00b0, input!\u00b0, sigmax!\u00b0, sigmay!\u00b0, sigmaxy!\u00b0, sigmax2!\u00b0, length!\u00b0, denominator!\u00b0, xlist!\u00b0, ylist!\u00b0; input!\u00b0:=%0; xlist!\u00b0:=map(log,map(part(~w!\u00b0,1), input!\u00b0)); ylist!\u00b0:=map(part(~w!\u00b0,2), input!\u00b0); length!\u00b0:=length(ylist!\u00b0); sigmax!\u00b0:=for each i in xlist!\u00b0 sum i; sigmay!\u00b0:= for each i in ylist!\u00b0 sum i; sigmax2!\u00b0:= for each i in xlist!\u00b0 sum i^2; sigmaxy!\u00b0:=for i:=1:length!\u00b0 sum part(xlist!\u00b0,i)*part(ylist!\u00b0,i);denominator!\u00b0:= length!\u00b0*sigmax2!\u00b0-sigmax!\u00b0**2; p2!\u00b0:=(length!\u00b0*sigmaxy!\u00b0-sigmax!\u00b0*sigmay!\u00b0)/denominator!\u00b0; p1!\u00b0:= (sigmay!\u00b0*sigmax2!\u00b0-sigmax!\u00b0*sigmaxy!\u00b0)/denominator!\u00b0; return p1!\u00b0+log(x)*p2!\u00b0 end >>
FitPoly.2=<< clear tmpx!\u00b0, tmpy!\u00b0; on rounded, roundall, numval; begin scalar xvec!\u00b0, yvec!\u00b0, input!\u00b0; input!\u00b0:= %0; xvec!\u00b0:=map(part(~w!\u00b0,1), input!\u00b0); yvec!\u00b0:= map(part(~w!\u00b0,2), input!\u00b0); tmpx!\u00b0:=vandermonde(xvec!\u00b0); tmpx!\u00b0:=sub\\_matrix(tmpx!\u00b0,for i:=1:length(input!\u00b0) collect i, for i:=1:(%1+1) collect i); tmpy!\u00b0:=listtocolumnvector(yvec!\u00b0);tmpx!\u00b0:=(1/(tp(tmpx!\u00b0)*tmpx!\u00b0))*tp(tmpx!\u00b0); tmpy!\u00b0:=tmpx!\u00b0*tmpy!\u00b0; return for i:=1:part(length(tmpy!\u00b0),1) sum tmpy!\u00b0(i,1)*x^(i-1) end>>
FitPow.1=<<on rounded, roundall, numval; begin scalar p1!\u00b0, p2!\u00b0, input!\u00b0, sigmax!\u00b0, sigmay!\u00b0, sigmaxy!\u00b0, sigmax2!\u00b0, length!\u00b0, denominator!\u00b0, xlist!\u00b0, ylist!\u00b0; input!\u00b0:=%0; xlist!\u00b0:=map(log,map(part(~w!\u00b0,1), input!\u00b0)); ylist!\u00b0:=map(log,map(part(~w!\u00b0,2), input!\u00b0)); length!\u00b0:=length(ylist!\u00b0); sigmax!\u00b0:=for each i in xlist!\u00b0 sum i; sigmay!\u00b0:= for each i in ylist!\u00b0 sum i; sigmax2!\u00b0:= for each i in xlist!\u00b0 sum i^2; sigmaxy!\u00b0:=for i:=1:length!\u00b0 sum part(xlist!\u00b0,i)*part(ylist!\u00b0,i);denominator!\u00b0:= length!\u00b0*sigmax2!\u00b0-sigmax!\u00b0**2; p2!\u00b0:=(length!\u00b0*sigmaxy!\u00b0-sigmax!\u00b0*sigmay!\u00b0)/denominator!\u00b0; p1!\u00b0:= exp((sigmay!\u00b0*sigmax2!\u00b0-sigmax!\u00b0*sigmaxy!\u00b0)/denominator!\u00b0); return p1!\u00b0*x^p2!\u00b0 end >>
#FitSin

Gamma.3=(((%1)*(%2))^(%0))/(%0)*kummerm(%0,%0+1,-(%1)*(%2))/beta(%0)
GCD.2=gcd(%0,%1)
GCD.1=<<begin scalar gcd!\u00b0; gcd!\u00b0:=0; for each term in (%0) do gcd!\u00b0:=gcd(gcd!\u00b0,term); return gcd!\u00b0 end >>
#GetPrecision.1

HCF.2=gcd(%0,%1)
HyperGeometric.5=<<begin scalar m,kk,ng,n; m:=%1$ ng:=%0$ n:=%2$ kk:=%3$ return if %4=true then sum(binomial(m,k)*binomial((ng-m),(n-k))/binomial(ng,n),k,0,kk) else binomial(m,kk)*binomial((ng-m),(n-kk))/binomial(ng,n) end>>

Identity.1=make\\_identity(%0)
If.2=if %0 then <<%1>>
If.3=if %0 then <<%1>> else <<%2>>
Imaginary.1=impart(%0)
ImplicitDerivative.3=-df(%0,%1)/df(%0,%2)
Integral.1=<<begin scalar integral!\u00b0; integral!\u00b0:=int(%0,ggbcasvarx); return if freeof(integral!\u00b0,'int) then integral!\u00b0 else '? end>>
Integral.2=<<begin scalar integral!\u00b0; integral!\u00b0:=int(%0,%1); return if freeof(integral!\u00b0,'int) then integral!\u00b0 else '? end>>
Integral.4=if numeric!\u00b0=0 then <<begin scalar integral!\u00b0; integral!\u00b0:=int(%0,%1,%2,%3); return if freeof(integral!\u00b0,'int) then integral!\u00b0 else '? end>> else num\\_int(%0,%1=(%2 .. %3))
IntegralBetween.4=if numeric!\u00b0=0 then <<begin scalar integral!\u00b0; integral!\u00b0:=int(%0-(%1),ggbcasvarx,%2,%3); return if freeof(integral!\u00b0,'int) then integral!\u00b0 else '? end>> else num\\_int(%0,%1=(%2 .. %3))
IntegralBetween.5=if numeric!\u00b0=0 then <<begin scalar integral!\u00b0; integral!\u00b0:=int(%0-(%1),%2,%3,%4); return if freeof(integral!\u00b0,'int) then integral!\u00b0 else '? end>> else num\\_int(%0,%1=(%2 .. %3))
Intersect.2=<<begin scalar eqn1!\u00b0, eqn2!\u00b0; eqn1!\u00b0:=%0; eqn2!\u00b0:=%1; if freeof(eqn1!\u00b0,=) then eqn1!\u00b0:= eqn1!\u00b0=y; if freeof(eqn2!\u00b0,=) then eqn2!\u00b0:= eqn2!\u00b0=y; return mysolve(list(eqn1!\u00b0,eqn2!\u00b0),list(ggbcasvarx,ggbcasvary)) end>>
Invert.1=1/(%0)
IntegerPart.1=if %0>0 then floor(%0) else ceiling(%0)
IsPrime.1=if primep(%0) then true else false
IsBound.1=if << symbolic; p!\u00b0:=isbound!\u00b0('%0); algebraic; p!\u00b0>>=1 then 'true else 'false

#KeepInput.1=

Last.1=last(%0)
Last.2=for i:=1:%1 collect part(%0,length(%0)-i)
LCM.1=<<begin scalar lcm!\u00b0; lcm!\u00b0:=0; for each term in (%0) do lcm!\u00b0:=lcm(lcm!\u00b0,term); return lcm!\u00b0 end >>
LCM.2=lcm(%0,%1)
Ld.1=logb(%0,2)
LeftSide.1=lhs(%0)
Length.3=int(sqrt(1+df(%0,ggbcasvarx)),ggbcasvarx,%1,%2)
Length.4=int(sqrt(1+df(%0,%1)),%1,%2,%3)
Lg.1=log10(%0)
Limit.2=limit(%0,ggbcasvarx,%1)
Limit.3=limit(%0,%1,%2)
LimitAbove.2=limit!+(%0,ggbcasvarx,%1)
LimitAbove.3=limit!+(%0,%1,%2)
LimitBelow.2=limit!-(%0,ggbcasvarx,%1)
LimitBelow.3=limit!-(%0,%1,%2)
Ln.1=log(%0)
Log.1=log10(%0)
Log.2=logb(%0,%1)

Max.N=max(%)
MatrixRank.1=rank(%0)
Mean.1=<<begin scalar list!\u00b0; list!\u00b0:=%0$ return 1/length(list!\u00b0)*for i:=1:length(list!\u00b0) sum part(list!\u00b0,i) end>>
Median.1=<<begin scalar list!\u00b0; list!\u00b0:=%0$ list!\u00b0:= sortnumlist list!\u00b0$ return if remainder(length(list!\u00b0),2)=0 then (part(list!\u00b0,length(list!\u00b0)/2)+part(list!\u00b0,1+length(list!\u00b0)/2))/2 else part(list!\u00b0,(length(list!\u00b0)+1)/2) end>>
Min.N=min(%)
Mod.2=mod!\u00b0(%0,%1)

NextPrime.1=nextprime(%0)
NIntegral.3=<<on numval, roundall$ num\\_int(%0,ggbcasvarx=((%1) .. (%2))) >>
NIntegral.4=<<on numval, roundall$ num\\_int(%0,%1=((%2) .. (%3))) >>
Normal.3=1/2*(1+erf((%2-(%0))/sqrt(2*(%1)^2)))
nPr.2=factorial(floor(%0))/factorial(floor(%0-%1))
NRoot.2=(%0)^(1/(%1))
NSolve.1=<<on rounded, numval, roundall$ num\\_solve(%0,ggbcasvarx) >>
NSolve.2=<<on rounded, numval, roundall$ num\\_solve(%0,%1) >>
NRoots.1=<<on rounded, numval, roundall$ num\\_solve(%0,ggbcasvarx) >>
NSolutions.1=<<on rounded, numval, roundall$ map(rhs,num\\_solve(%0,ggbcasvarx)) >>
Numerator.1=num(%0)
Numeric.1=<<numeric!\u00b0:=1; on rounded, roundall, numval$ %0>>
Numeric.2=<<numeric!\u00b0:=1; on rounded, roundall, numval$ if %1<=16 then <<print\\_precision(%1)$ %0>> else <<precision(%1)$ print\\_precision(%1)$ %0 >> >>
N.1=<<numeric!\u00b0:=1; on rounded, roundall, numval$ %0>>
N.2=<<numeric!\u00b0:=1; on rounded, roundall, numval$ if %1<=16 then <<print\\_precision(%1)$ %0>> else <<precision(%1)$ print\\_precision(%1)$ %0 >> >>

OrthogonalVector.1=if arglength(%0)>-1 and part(%0,0)='list then list(-part(%0,2),part(%0,1)) else mat((0,-1),(1,0))*(%0)

PartialFractions.1=part(pf(%0,ggbcasvarx),0):=+
Pascal.4=if %3=true then betaRegularized(%0,1+floor(%2),%1) else (1-(%1))^(%2)*(%1)^(%0)*binomial(%0+%2-1,%0-1)
Poisson.3=if %2=true then exp(-(%0))*for i:=0:(%1) sum (%0)^i/factorial(floor(i)) else (%0)^(%1)/factorial(floor(%1))*exp(-%0)
PreviousPrime.1=<<begin scalar tmp!\u00b0; tmp!\u00b0:=%0-1; while not(primep(tmp!\u00b0)) and not(tmp!\u00b0<3) do tmp!\u00b0:=tmp!\u00b0-1; return if primep(tmp!\u00b0) then tmp!\u00b0 else ? end>>
PrimeFactors.1=<<off rounded; begin scalar factorlist!\u00b0; factorlist!\u00b0:=factorize(%0); factorlist!\u00b0:= for each x!\u00b0 in factorlist!\u00b0 collect for i:=1:part(x!\u00b0,2) collect part(x!\u00b0,1); return mkdepth\\_one(factorlist!\u00b0) end>>
Product.1=for i:=1:length(%0) product part(%0,i)
Product.4=prod(%0,%1,%2,%3)
Prog.1=<<%0>>
Prog.2=<<begin scalar %0; return %1 end>>
ProperFraction.1=<<begin scalar result!\u00b0; result!\u00b0:=list(if %0>0 then floor(%0) else ceiling(%0),if (%0)>0 then %0-floor(%0) else %0-ceiling(%0)); return if part(result!\u00b0,2)=0 then part(result!\u00b0,1) else part(result!\u00b0,0):=+ end>>

Random.2=random(%1-%0+1)+%0
RandomBinomial.2=<<on rounded, roundall, numval; for each x in for i:=1:%0 collect random(10000000)/10000000 sum if (x<%1) then 1 else 0 >>
RandomElement.1=part(%0,random(length(%0))+1)
RandomPoisson.1=<<on rounded, roundall, numval; -log(random(10000000)/10000000)/(%0)>>
RandomNormal.2=<<on rounded, roundall, numval; %0+(%1)*cos(2*pi*random(10000000)/10000000)*sqrt(-2*log(random(10000000)/10000000)) >>
RandomPolynomial.3=randpoly(ggbcasvarx, maxdeg=%0, coeffs=rand(%1 .. %2))
RandomPolynomial.4=randpoly(%0, maxdeg=%1, coeffs=rand(%2 .. %3))
Rationalize.1=<<off rounded; %0 >>
Real.1=repart(%0)
RightSide.1=rhs(%0)
Root.1=if numeric!\u00b0=0 then mysolve(%0,ggbcasvarx) else num\\_solve(%0,ggbcasvarx)
ReducedRowEchelonForm.1=<<begin scalar tmpmatrix, tmpcolumn; tmpmatrix:=%0$ tmpcolumn:=1$for i:=1:row\\_dim(tmpmatrix) do <<if tmpmatrix(i,tmpcolumn)=0 then while (tmpcolumn<=column\\_dim(tmpmatrix) and tmpmatrix(i,tmpcolumn)=0 and i<=row\\_dim(tmpmatrix)) do << for j:=i+1:row\\_dim(tmpmatrix) do if (tmpmatrix(i,j) neq 0) then tmpmatrix:=swap\\_rows(tmpmatrix,tmpcolumn, j)$ if (tmpmatrix(i,tmpcolumn)=0) then tmpcolumn:=tmpcolumn+1>>$ if tmpcolumn<=column\\_dim(tmpmatrix) then if tmpmatrix(i, tmpcolumn) neq 0 then << tmpmatrix:=pivot(tmpmatrix,i,tmpcolumn); tmpmatrix:=mult\\_rows(tmpmatrix,i,1/tmpmatrix(i,tmpcolumn))$ tmpcolumn:=tmpcolumn+1; >> >>$ return tmpmatrix end>>

Sample.2=for i:=1:%1 collect part(%0,1+random(length(%0)))
Sample.3=<< begin scalar list!\u00b0; list!\u00b0:=%0; return if %2=true then for i:=1:%1 collect part(list!\u00b0,1+random(length(list!\u00b0))) else for i:=1:%1 collect(part(num\\_to\\_perm(1+random(myfactorial(length(list!\u00b0))),list!\u00b0),i) end >>
SampleVariance.1=<< begin scalar n!\u00b0, list!\u00b0; list!\u00b0:=%0; n!\u00b0:=length(%0); return 1/(n!\u00b0-1)*(for each i in list!\u00b0 sum i^2)-1/(n!\u00b0^2-n!\u00b0)*(for each i in list!\u00b0 sum i)^2 end >>
SampleSD.1=<< begin scalar n!\u00b0, list!\u00b0; list!\u00b0:=%0; n!\u00b0:=length(%0); return sqrt(1/(n!\u00b0-1)*(for each i in list!\u00b0 sum i^2)-1/(n!\u00b0^2-n!\u00b0)*(for each i in list!\u00b0 sum i)^2) end >>
Sequence.1=for i:=1:(%0) collect i
Sequence.4=<<begin scalar %1; return for %1:=(%2):(%3) collect (%0) end>>
Sequence.5=<<begin scalar %1; return for %1:=(%2) step (%4) until (%3) collect (%0) end>>
SetPrecision.1=<<printprecision!\u00b0:=%0; print\\_precision printprecision!\u00b0>>
SetPrecision.2=<<precision!\u00b0:=%0; precision precision!\u00b0>>
SD.1=<<begin scalar tmpmean, tmplist; tmplist:=%0$ tmpmean:=0$ tmpmean:= (1/length(tmplist))*for i:=1:length(tmplist) sum part(tmplist,i)$ return sqrt((1/length(tmplist))*for i:=1:length(tmplist) sum (part(tmplist,i)^2-tmpmean^2)) end>>
Shuffle.1=<<begin scalar tmpret; tmpret:=(%0)$ return num\\_to\\_perm(random(length(tmpret)),tmpret) end>>
Sign.1=sign(%0)
Simplify.1=%0
SimplifyFull.1=simplify(%0)
Solutions.1=map(rhs,mysolve(%0,ggbcasvarx))
Solutions.2=map(rhs,mysolve(%0,%1))
Solve.1=mysolve(%0,ggbcasvarx)
Solve.2=<< begin scalar equations!\u00b0; equations!\u00b0:=%0; if arglength(equations!\u00b0)>-1 and part(equations!\u00b0,0)='list then equations!\u00b0:=mkdepthone(equations!\u00b0); return mysolve(equations!\u00b0,%1) end >>
SolveODE.1=<<begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(ggbcasvary,ggbcasvarx)=tmpeqn,ggbcasvary,ggbcasvarx) else tmpret:=odesolve(tmpeqn,ggbcasvary,ggbcasvarx)$ return if length(tmpret)=1 then first(tmpret) else tmpret end>>
SolveODE.3=begin scalar tmpret, tmpeqn; tmpeqn:=%0$ if freeof(tmpeqn,=) then tmpret:=odesolve(df(%1,%2)=tmpeqn,%1,%2) else tmpret:=odesolve(tmpeqn,%1,%2)$ return if length(tmpret)=1 then first(tmpret) else tmpret end
Sqrt.1=sqrt(%0)
#Substitute.2=if hold!\u00b0=0 then sub(%1,%0) else sub(%1, !*hold(%0))
#Substitute.3=if hold!\u00b0=0 then sub(%1=%2,%0) else sub(%1=%2,!*hold(%0))
Substitute.3=sub(%1=%2,%0)
#SubstituteParallel.2=if hold!\u00b0=0 then sub(%1,%0) else sub(%1,!*hold(%0))
SubstituteHold.2=sub(%1, !*hold(%0))
Sum.1=for i:=1:length(%0) sum part(%0,i)
Sum.4=sum(%0,%1,%2,%3)

Take.3=<<begin scalar tmpret; tmpret:=list()$ for i:=%1:%2 do tmpret:=part(%0,i).tmpret$ return reverse(tmpret) end>>
TaylorSeries.3=<<on div$ off pri$ taylortostandard(taylor(%0,ggbcasvarx,%1,%2))>>
TaylorSeries.4=<<on div$ off pri$ taylortostandard(taylor(%0,%1,%2,%3))>>
TDistribution.2=<<begin scalar t,n; n!\u00b0:=%0; t!\u00b0:=%1 ;beta!Regularized(((t!\u00b0+sqrt(t!\u00b0^2+n!\u00b0)/(2*sqrt(t!\u00b0^2+n!\u00b0)),n!\u00b0/2,n!\u00b0/2)
ToBinomial.1=%0
ToPolar.1=part(list(sqrt(repart(%0)^2+impart(%0)^2),atan2(repart(%0),impart(%0))),0):=complexpolar
ToExponential.1=part(list(sqrt(repart(%0)^2+impart(%0)^2),part(list(i*atan2(repart(%0),impart(%0))),0):=exp),0):=*
Transpose.1=tp(%0)

Unique.1=mkset(%0)
UnitOrthogonalVector.1=<<begin; clear mat!\u00b0,norm!\u00b0; input!\u00b0:=%0;return if arglength(input!\u00b0)>-1 and part(input!\u00b0,0)='list then <<norm!\u00b0:=sqrt(<<for each i in input!\u00b0 sum i^2>>); list(-part(input!\u00b0,2)/norm!\u00b0,part(input!\u00b0,1)/norm!\u00b0) >> else <<norm!\u00b0:=sqrt(<<for i:=1:row\\_dim(input!\u00b0) sum input!\u00b0(i,1)^2>>); norm!\u00b0*mat((0,-1),(1,0))*input!\u00b0 >> end >>
UnitVector.1=<<begin; clear input!\u00b0; input!\u00b0:=%0; return if arglength(input!\u00b0)>-1 and part(input!\u00b0,0)='list then map(~w/sqrt(<<for each i in input!\u00b0 sum i^2>>),input!\u00b0) else input!\u00b0/sqrt(<<for i:=1:row\\_dim(input!\u00b0) sum input!\u00b0(i,1)^2>>) end>>

Variance.1=<<begin scalar x!\u00b0,n!\u00b0,xd!\u00b0; x!\u00b0:=%0$ n!\u00b0:=length(x!\u00b0)$ xd!\u00b0:=1/n!\u00b0*for each i in x!\u00b0 sum i; return 1/n!\u00b0* for each i in x!\u00b0 sum (i-xd!\u00b0)**2 end>>

Weibull.3=1-exp(-(%0)*(%2)^(%1))

Zipf.4=<<begin scalar s; s:= %1; return if %3=true then harmonic(%2,s)/harmonic(%0,s) else 1/((%2)^s*harmonic(%0,s)) end>>