####
# Command translation table from GeoGebra to MPReduce
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=ABS(%0)
#Argument.1

Binomial.2=BINOMIAL(%0,%1)
#Cauchy.3
Ceil.1=ceiling(%0);
#CFactor.1=
#CFactor.2
#ChiSquared.2
#Coefficients.1
CommonDenominator.2=lcm(den(%0),den(%1))
Complex.2=%0+I*(%1)
#ComplexPolar.2
#ComplexRoot.1
Conjugate.1=CONJ(%0)
#Covariance.2
#Covariance.1
Cross.2=<<MATRIX MATRIXTEMP1,MATRIXTEMP2; MATRIXTEMP1:=%0; MATRIXTEMP2=%1;MAT((MATRIXTEMP1(1)*MATRIXTEMP2(2)-MATRIXTEMP1(2)*MATRIXTEMP2(1)),(MATRIXTEMP1(2)*MATRIXTEMP2(0)-MATRIXTEMP1(0)*MATRIXTEMP2(2)),(MATRIXTEMP1(0)*MATRIXTEMP2(1)-MATRIXTEMP1(1)*MATRIXTEMP2(0)))>>
#CSolutions.1
#CSolutions.2
#CSolve.1

#CSolve.2

Decimal.1=1.0*(%0)
Degree.1=deg(%0,x)
Delete.1= clear %0
Denominator.1=den(%0)
Derivative.1=df(%0,x)
Derivative.2=df(%0,%1)
Derivative.3=df(%0,%1,%2)
Determinant.1=det(%0)
Dimension.1=length(%0)
Div.2=round((%0)/(%1))
Division.2={round((%0)/(%1)),(%0)-(%1)*round((%0)/(%1))}
Divisors.1=<<clear ret$ ret:=0$ for i:=1:%0 do if remainder(%0,i)=0 then ret:=ret+1$ ret>>
DivisorsList.1=<<clear ret$ ret:={}$ for i:=1:%0 do if remainder(%0,i)=0 then ret:=i.ret$ reverse(ret)>>
DivisorsSum.1=<<clear ret$ ret:=0$ for i:=1:%0 do if remainder(%0,i)=0 then ret:=ret+i$ ret>>
#Dot.2

Element.2=part(%0,%1)
Element.3=<<clear ret$ ret:={}$ for i:=%1:%2 do ret:=part(%0,i).ret$ reverse(ret)>>
Expand.1=%0
#ExpandComplex.1
#Exponential.2

#Factor.1
#FDistribution.3
First.1=first(%0)
First.2=<<clear ret$ ret:={}$ for i:=1:%1 do ret:=part(%0,i).ret$ reverse(ret)>>
Floor.1=floor(%0)
#FractionalPart.1

#Gamma.3
GCD.2=gcd(%0,%1)
#GetPrecision.1

HCF.2=gcd(%0,%1)

If.2=<<if %0 then %1>>
If.3=<<if %0 then %1 else %2>>
Imaginary.1=impart(%0)
#ImplicitDerivative.3
Integral.1=int(%0,x)
Integral.2=int(%0,%1)
Integral.4=int(%0,%1,%2,%3)
#Intersect.2
Invert.1=1/(%0)
#IntegerPart.1
IsPrime.1=if primep(%0) then true else false

#KeepInput.1

Last.1=last(%0)
Last.2=<<clear ret$ ret:={}$ for i:=1:%1 do ret:=part(%0,length(%0)-i).ret$ ret>>
LCM.2=lcm(%0,%1)
Ld.1=logb(%0,2)
#LeftSide.1
#Length.3
#Length.4
Lg.1=log10(%0)
Limit.2=limit(%0,x,%1)
Limit.3=limit(%0,%1,%2)
LimitAbove.2=limit!+(%0,x,%1)
LimitAbove.3=limit!+(%0,%1,%2)
LimitBelow.2=limit!-(%0,x,%1)
LimitBelow.3=limit!-(%0,%1,%2)
Ln.1=log(%0)
Log.1=log10(%0)
Log.2=logb(%0,%1)

Max.N=max(%)
Mean.1=<<clear tmplist, tempret$ tempret:=0$ templist:=%0$ for i:=1:length(tmplist) do tempret:=tempret+part(tempret,i)$ tempret/length(templist)>>
Median.1=<<clear tmplist$ tmplist:=%0$ tmplist:= sortnumlist tmplist$ if remainder(length(tmplist),2)=0 then (part(tmplist,length(templist)/2)+part(tmplist,1+length(templist)/2))/2 else part(tmplist,(length(templist)+1)/2)>>
Min.N=min(%)
Mod.2=remainder(%0,%1)

NextPrime.1=nextprime(%0)
#NIntegral.3
#NIntegral.4
#Normal.3
nPr.2=(factorial(%0)/factorial(%0-%1))
#NRoot.2
#NSolve.1
#NRoots.1
#NSolutions.1
Numerator.1=num(%0)
Numeric.1= <<on rounded$ %0 ; off rounded$>>
#Numeric.2
#N.1
#N.2

#OrthogonalVector.1

#PartialFractions.1
#Pascal.4
#PreviousPrime.1
#PrimeFactors.1
#Product.1
#Product.4
#Prog.1
#ProperFraction.1

Random.2=%0+random(%1-%0+1)
#RandomBinomial.2
#RandomElement.1
#RandomPoisson.1
#RandomNormal.2
#RandomPolynomial.3
#RandomPolynomial.4
#Rank.1
#Rationalize.1
#Real.1
#RightSide.1
#Root.1
#ReducedRowEchelonForm.1

#Sample.2
#Sample.3
#SampleVariance.1
#SampleSD.1
#Sequence.4
#Sequence.5
#SetPrecision.1
#SD.1
#Shuffle.1
#Sign.1
Simplify.1=%0
#SimplifyFull.1
#Solutions.1
#Solutions.2
Solve.1=solve(%0)
Solve.2=solve(%0,%1)
#SolveODE.1 
#SolveODE.3 
Sqrt.1=sqrt(%0)
#Substitute.2
#Substitute.3
#SubstituteParallel.2
Sum.1=<<clear ret$ ret:=0 $ for i:=1:length(%0) do ret:=ret+part(%0,i); ret>>
Sum.4=sum(%0,%1,%2,%3)

Take.3=<<clear ret$ ret:={}$ for i:=%1:%2 do ret:=part(%0,i).ret$ reverse(ret)>>
#Taylor.3
#Taylor.4
#TDistribution.2
#ToBinomial.1
#ToPolar.1
#ToExponential.1
Transpose.1=TP(%0)

#Unique.1
#UnitOrthogonalVector.1
#UnitVector.1

#Variance.1

#Weibull.3

#Zipf.4