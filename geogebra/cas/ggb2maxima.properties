####
# Command translation table from GeoGebra to Maxima
# e.g. Factor[ 2(x+3) ] is translated to factor( 2*(x+3) );
###

Abs.1=abs(%0)
Arg.1=carg(%0)

BinomPdf.3=(1-%1)^(%0-%2)*(%1)^(%2)*binomial(%0,%2)
BinomPdf.2=makelist((1-%1)^(%0-i)*(%1)^(i)*binomial(%0,i),i,0,%1)
BinomCdf.3=sum((1-%1)^(%0-i)*(%1)^(i)*binomial(%0,i),i,0,%2), simpsum
BinomCdf.2=makelist(ev(sum((1-%1)^(%0-i)*(%1)^(i)*binomial(%0,i),i,0,ind2), simpsum),ind2,0,%1)

Coefficients.1=coefflist(%0,x)
ComDenom.1=lcm(denom(%0),denom(%1))
Complex.2=%0+%1*(%i)
Degree.1=degree(%0,x)
Delete.1=kill(%0)
Denominator.1=denom(%0)
Derivative.1=diff(%0,x)
Derivative.2=diff(%0,%1)
Derivative.3=diff(%0,%1,%2)
Determinant.1=determinant(%0)
Div.2=first(divide(%0, %1))

Element.2=part(%0, %1)
Element.3=part(part( %0, %1 ), %2)
Expand.1=expand(%0)

Factor.1=factor(%0)
FPart.1=%0-signum(%0)*floor(abs(%0))

GetDenom.1=denom(%0)
GetPrecision.1=fpprec
GetNum.1=num(%0)
GCD.2=gcd(%0, %1)

HCF.2=gcd(%0, %1)

# TODO use this when we support constants of integration
#Integral.1=part(integrate(0=%0,x),2)
Integral.1=integrate(%0,x)
Integral.2=integrate(%0,%1)
Integral.4=integrate(%0,%1,%2,%3)

Invert.1=invert(%0)
IPart.1=signum(%0)*floor(abs(%0))

# TODO implement keep input like Hold in MathPiper
KeepInput.1=%0

LCM.2=lcm(%0, %1)
LeftSide.1=part(%0,1)
Limit.2=limit(%0,x,%1)
Limit.3=limit(%0, %1, %2)
LimitAbove.2=limit(%0,x,%1,plus)
LimitAbove.3=limit(%0,%1,%2,plus)
LimitBelow.2=limit(%0,x,%1,minus)
LimitBelow.3=limit(%0,%1,%2,minus)

Ln.1=ratsimp(log(%0))
Ld.1=log_a(%0,2)
Lg.1=log_a(%0,10)
Log.1=log_a(%0,10)
#Log.2=block([oldLE, ret], oldLE:logexpand, logexpand:super, ret: (log((%1)^dummy*%0)/log(%1))-dummy, logexpand:oldLE, logcontract(ret))
Log.2=log_a(%0,%1)

Max.N=lmax([%])
Min.N=lmin([%])
Mod.2=last(divide(%0, %1))
MSolve.2=block([s : solve(%0, %1)], for i : 1 thru length (%rnum\_list) do s : subst (simplode([t, i]), %rnum\_list[i], s), return (if (length(s) = 1) then flatten(s) else (s)))

nCr.2=binomial(%0,%1)
nPr.2=permutation(%0,%1)
NIntegral.3=block([result, d1,d2,d3],if %1=-inf or %2=inf then [result,d1,d2,d3]:(quad_qagi(%0,x,subst(-inf=minf,%1),%2)) else [result,d1,d2,d3]:(quad_qags(%0,x,%1,%2)),result)
NIntegral.4=block([result, d1,d2,d3],if %2=-inf or %3=inf then [result,d1,d2,d3]:(quad_qagi(%0,%1,subst(-inf=minf,%2),%3)) else [result,d1,d2,d3]:(quad_qags(%0,%1,%2,%3)),result)
NormPdf.3=exp(-(%2-%0)^2/(2*(%1)^2))/(sqrt(2*%pi)*(%1))
NormCdf.3=integrate(exp(-(xvar-%0)^2/(2*(%1)^2))/(sqrt(2*%pi)*(%1)),xvar,minf,%2)
NormCdf.4=integrate(exp(-(xvar-%0)^2/(2*(%1)^2))/(sqrt(2*%pi)*(%1)),xvar,%2,%3)
NRoot.2=(if sign((-1)^(%1))=1 then abs(%0)^(1/%1) else (%0)^(1/%1))
NSolve.1=realroots(%0)
Numerator.1=num(%0)
Numeric.1=bfloat(%0)
Numeric.2=block([oldPrec, ret], oldPrec:fpprec, fpprec:%1, fpprintprec:%1, ret:bfloat(%0), fpprec:oldPrec, fpprintprec:oldPrec, ret)


PartialFractions.1=partfrac(%0,x)
Product.1=product(%0[i],i,1,length(%0)), simpproduct
Product.4=product(%0,%1,%2,%3), simpproduct
Prog.1=block(%0);
PropFrac.1='(signum(%0)*floor(abs(%0)))+'(%0-signum(%0)*floor(abs(%0)))

# if %0 is a list, we need to flatten it first.
RightSide.1=block([x: %0], return (if (length(x) = 1) then part(first(x), 2) else (part(x, 2))))
Root.1=realroots(%0)
rref.1=echelon(%0)

Seq.4=makelist(%0,%1,%2,%3)
Seq.3=makelist(%0,x,%1,%2)
Sequence.4=makelist(%0,%1,%2,%3)
Sequence.3=makelist(%0,x,%1,%2)

SetPrecision.1=block(fpprec:%0,fpprintprec:%0)
Sgn.1=signum(%0)
Simplify.1=ratsimp(%0)
SimplifyFull.1=ratsimp(trigsimp(%0))
Solutions.1=flatten(stripequals(solve([%0],[x])))
Solutions.2=stripequals(solve(%0,%1))
Solve.1=flatten(solve([%0],[x])

# Maxima always returns a set of solution-sets. If there's only 1 solution, 
# we should flatten it (MathPiper has flattened solution-lists!), otherwise we don't.
# Also, see the maxima-documentation about %rnum_list for the for-loop!
Solve.2=block([s : solve(%0, %1)], for i : 1 thru length (%rnum\\_list) do s : subst (simplode([t, i]), %rnum\\_list[i], s), return (if (length(s) = 1) then flatten(s) else (s)))

SolveODE.1=ode2('diff(y,x) - (%0),y,x) 
SolveODE.3=ode2('diff(%1,%2) - (%0),%1,%2) 

Sqrt.1=sqrt(%0)

#TODO: make substitute work for equation results
# substitute list of equations, e.g. Substitute[x + 5,  {x=-2, x=2}] gives {3, 7}
Substitute.2=map( lambda([eqn], subst(eqn, %0)), %1)
Substitute.3=subst(%2, %1 ,%0)sch
SubstituteParallel.2=psubst(makelist(%0[i][1]=%0[i][2],i,1,length(%0)),%1)

Sum.1=sum(%0[i],i,1,length(%0)), simpsum
Sum.4=sum(%0,%1,%2,%3), simpsum

Taylor.3=taylor(%0,x,%1,%2) 
Taylor.4=taylor(%0,%1,%2,%3) 

Transpose.1=transpose(%0)

UnitVector.1=unitvector(%0)
OrthogonalVector.1=[-part(%0, 2), part(%0, 1)]
UnitOrthogonalVector.1=unitvector([-part(%0, 2), part(%0, 1)])
