####
# Command translation table from GeoGebra to Maxima
# e.g. Factor[ 2(x+3) ] is translated to factor( 2*(x+3) );
###

Coefficients.1=coefflist(%0,x)

Degree.1=degree(%0,x)
Delete.1=kill(%0)
Denominator.1=denom(%0)
Derivative.1=diff(%0,x)
Derivative.2=diff(%0,%1)
Derivative.3=diff(%0,%1,%2)
Determinant.1=determinant(%0)
Div.2=first(divide(%0, %1))

Element.2=part(%0, %1)
Element.3=part(part( %0, %1 ), %2)
Expand.1=expand(%0)

Factor.1=factor(%0)

GetPrecision.1=fpprec
GCD.2=gcd(%0, %1)

HCF.2=gcd(%0, %1)

# TODO use this when we support constants of integration
#Integral.1=part(integrate(0=%0,x),2)
Integral.1=integrate(%0,x)
Integral.2=integrate(%0,%1)
Integral.4=integrate(%0,%1,%2,%3)

Invert.1=invert(%0)

# TODO implement keep input like Hold in MathPiper
KeepInput.1=%0

LCM.2=lcm(%0, %1)
LeftSide.1=part(%0,1)
Limit.2=limit(%0,x,%1)
Limit.3=limit(%0, %1, %2)
LimitAbove.2=limit(%0,x,%1,plus)
LimitAbove.3=limit(%0,%1,%2,plus)
LimitBelow.2=limit(%0,x,%1,minus)
LimitBelow.3=limit(%0,%1,%2,minus)

Max.N=lmax([%])
Min.N=lmin([%])
Mod.2=last(divide(%0, %1))

Numerator.1=num(%0)
Numeric.1=bfloat(%0)
Numeric.2=block([oldPrec, ret], oldPrec:fpprec, fpprec:%1, fpprintprec:%1, ret:bfloat(%0), fpprec:oldPrec, fpprintprec:oldPrec, ret)

PartialFractions.1=partfrac(%0,x)
Prog.1=block(%0);

# if %0 is a list, we need to flatten it first.
RightSide.1=block([x: %0], return (if (length(x) = 1) then part(first(x), 2) else (part(x, 2))))
rref.1=echelon(%0)
SetPrecision.1=block(fpprec:%0,fpprintprec:%0)
Simplify.1=ratsimp(%0)
SimplifyFull.1=ratsimp(trigsimp(%0))
Solutions.1=flatten(stripequals(solve([%0],[x])))
Solutions.2=stripequals(solve(%0,%1))
Solve.1=flatten(solve([%0],[x]))

# Maxima always returns a set of solution-sets. If there's only 1 solution, 
# we should flatten it (MathPiper has flattened solution-lists!), otherwise we don't.
# Also, see the maxima-documentation about %rnum_list for the for-loop!
Solve.2=block([s : solve(%0, %1)], for i : 1 thru length (%rnum\_list) do s : subst (simplode([t, i]), %rnum\_list[i], s), return (if (length(s) = 1) then flatten(s) else (s)))

SolveODE.1=ode2('diff(y,x) - (%0),y,x) 
SolveODE.3=ode2('diff(%1,%2) - (%0),%1,%2) 

#TODO: make substitute work for equation results
# substitute list of equations, e.g. Substitute[x + 5,  {x=-2, x=2}] gives {3, 7}
Substitute.2=map( lambda([eqn], subst(eqn, %0)), %1)
Substitute.3=subst(%2, %1 ,%0)sch
SubstituteParallel.2=psubst(makelist(%0[i][1]=%0[i][2],i,1,length(%0)),%1)

Sum.1=sum(%0[i],i,1,length(%0)), simpsum
Sum.4=sum(%0,%1,%2,%3), simpsum

Taylor.3=taylor(%0,x,%1,%2) 
Taylor.4=taylor(%0,%1,%2,%3) 

Transpose.1=transpose(%0)

UnitVector.1=unitvector(%0)
OrthogonalVector.1=[-part(%0, 2), part(%0, 1)]
UnitOrthogonalVector.1=unitvector([-part(%0, 2), part(%0, 1)])
