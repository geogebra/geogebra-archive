####
# Command translation table from GeoGebra to MathPiper
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###
CheckInput.1=Hold(%0)
Coefficients.1=Coef(%0,x,0 .. Degree(%0))
Degree.1=Degree(%0)
Delete.1=[Unbind(%0); Retract("%0", *);]
Denominator=Denom(%0)
Derivative.1=Eval(Differentiate(x) %0)
Derivative.2=Eval(Differentiate(%1) %0)
Derivative.3=Eval(Differentiate(%1, %2) %0)
Div.2=Quotient(%0, %1)
Element.2=Nth(%0, %1)
Element.3=Nth(Nth( %0, %1 ), %2)
Expand.1=ExpandBrackets(%0)
Evaluate.1=Eval(%0)
Factor.1=Factor(Rationalize(%0))
Factors.1=Factors(Rationalize(%0))
Floor.1=Floor(N(%1))
GetPrecision.1=BuiltinPrecisionGet(%0)
GCD.2=Gcd(%0, %1)
HCF.2=Gcd(%0, %1)
# add eval for integral to allow function definitions, e.g. f(x) := Integral(x^2, x)
Integral.1=Eval(AntiDeriv(x, %0))
Integral.2=Eval(AntiDeriv(%1, %0))
Integral.4=Eval(Integrate(%1, %2, %3) %0)
LeftSide.1=If(IsList(%0), EquationLeft(Nth(%0,1)), EquationLeft(%0))
Limit.2=Limit(x,%1)%0
Limit.3=Limit(%1, %2) %0
LimitAbove.2=(Limit(x,%1,Right)%0)
LimitAbove.3=(Limit(%1,%2,Right)%0)
LimitBelow.2=(Limit(x,%1,Left)%0)
LimitBelow.3=(Limit(%1,%2,Left)%0)
LCM.2=Lcm(%0, %1)
#Max.1=Maximum(%0)
#Max.2=Maximum(%0, %1)
#Min.1=Minimum(%0)
#Min.2=Minimum(%0,%1)
Max.N=Maximum({%})
Min.N=Minimum({%})
Mod.2=Modulo(%0, %1)
Numerator=Numer(%0)
Numeric.1=N(%0)
Numeric.2=N(%0, %1)
PartialFractions.1=Apart(%0)
Prog.1=[ %0 ;]
RightSide.1=If(IsList(%0), EquationRight(Nth(%0,1)), EquationRight(%0))
SetPrecision.1=BuiltinPrecisionSet(%0)
Simplify.1=Simplify(%0)
# used by AlgoSimplify
SimplifyFull.1=Simplify(TrigSimpCombine(FactorCancel(%0)))
#SimplifyFull.1=Simplify(TrigSimpCombine(%0))


# Solutions gives a list like {2,4} instead of {x==2, x==4}
Solutions.1=RemoveDuplicates(MapArgs( Solve( %0, x), {{elem}, Nth(elem,2)} ))
Solutions.2=RemoveDuplicates(MapArgs( Solve( %0, %1), {{elem}, Nth(elem,2)} ))
# Solve for two equations gives results like {{x==2-y,y==5/4}}, so we substitute y into the expression for x
# old: Solutions2.2=RemoveDuplicates(MapArgs( Solve({%0, %1}, {x, y}), {{elem}, Nth(elem,2)} ));
# old: Solutions2.4=RemoveDuplicates(MapArgs( Solve({%0, %1}, {%2, %3}),  {{elem}, {Nth(Nth(elem,1),2),Nth(Nth(elem,2),2)}} ));
Solutions2.2=[ Local(solve, list); solve := RemoveDuplicates(Solve({%0, %1}, {x, y})); list:= MapArgs( solve, {{elem}, {  Nth(Nth(elem,1),2), Nth(Nth(elem,2),2)} });  Table( WithValue(y, Nth(Nth(list,i),2), Nth(list,i)) , i, 1, Length(list), 1); ]
Solutions2.4=[ Local(solve, list); solve := RemoveDuplicates(Solve({%0, %1}, {%2, %3})); list:= MapArgs( solve, {{elem}, {  Nth(Nth(elem,1),2), Nth(Nth(elem,2),2)} });  Table( WithValue(%3, Nth(Nth(list,i),2), Nth(list,i)) , i, 1, Length(list), 1); ]

# Solve gives a list like {x==2, x==4}
Solve.1=RemoveDuplicates(Solve(%0, x))
Solve.2=RemoveDuplicates(Solve(%0, %1))
# Solve for two equations gives results like {{x==2-y,y==5/4}}, so we substitute y into the expression for x
# old: Solve2.2=RemoveDuplicates(Solve({%0, %1}, {x, y}))
# old: Solve2.4=RemoveDuplicates(Solve({%0, %1}, {%2, %3}))
Solve2.2= [ Local(list); list:= RemoveDuplicates(Solve({%0, %1}, {x, y}));  Table( {WithValue(y, Nth(Nth(Nth(list,i),2),2), Nth(Nth(list,i),1)), Nth(Nth(list, i),2)} , i, 1, Length(list), 1); ]
Solve2.4= [ Local(list); list:= RemoveDuplicates(Solve({%0, %1}, {%2, %3}));  Table( {WithValue(%3, Nth(Nth(Nth(list,i),2),2), Nth(Nth(list,i),1)), Nth(Nth(list, i),2)} , i, 1, Length(list), 1); ]

Sum.4=Sum(%1, %2, %3, %0)
SumList.N=Sum(i, 1, Length({%}), Nth({%},i))
Substitute.3=[ Local(resultHold); resultHold := (Subst(%1, %2) Hold(%0)); If(resultHold != Hold(%0), resultHold, (Subst(%1, %2) %0));]
Taylor.3=Taylor3(x,%1,%2)(%0) 
Taylor.4=Taylor3(%1,%2,%3)(%0) 