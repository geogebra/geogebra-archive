####
# Command translation table from GeoGebra to MathPiper
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=If(IsVector(%0),Norm(%0),Abs(%0))
ArcLen.3=Integrate(x,%1,%2) Sqrt(1+(Differentiate(x) %0)^2)
ArcLen.4=Integrate(%1,%2,%3) Sqrt(1+(Differentiate(%1) %0)^2)
Arg.1=Arg(%0)

BinomCdf.3=CDF(BinomialDistribution(%1,%0),%2)
BinomCdf.2=Table(CDF(BinomialDistribution(%1,%0),ind),ind,0,%1)
BinomPdf.3=PMF(BinomialDistribution(%1,%0),%2)
BinomPdf.2=Table(PMF(BinomialDistribution(%1,%0),ind),ind,0,%1)

Ceil.1=Ceil(N(%0))
CFactor.2=Product(%1-(xPSolve(%0,%1)))
CFactor.1=Product(x-(xPSolve(%0,x)))
Coefficients.1=Coef(%0,x,0 .. Degree(%0))
ComDenom.2=Lcm(Denominator(%0),Denominator(%1))
Complex.2=(%0+%1*I)
ComplexPolar.2=%0*Cos(%1)+%0*I*Sin(%1)
ComplexRoot.1=RemoveDuplicates(xPSolve(%0, x))
Conjugate.1=Conjugate(%0)
Cross.2=CrossProduct(%0,%1)
CSolve.1=MapSingle("x=",RemoveDuplicates(xPSolve(%0, x)))
CSolve.2=MapSingle("%1=",RemoveDuplicates(xPSolve(%0, %1))
CSolutions.1=RemoveDuplicates(xPSolve(%0, x))
CSolutions.2=RemoveDuplicates(xPSolve(%0, %1))

Degree.1=Degree(%0)
Delete.1=[Unbind(%0); Retract("%0", *);]
Denominator=Denominator(%0)
Derivative.1=Eval(Differentiate(x) %0)
Derivative.2=Eval(Differentiate(%1) %0)
Derivative.3=Eval(Differentiate(%1, %2) %0)
Determinant.1=RecursiveDeterminant(%0)
Dim.1=Length(%0)
Div.2=Quotient(%0, %1)
Division.2={Quotient(%0, %1), Modulo(%0,%1)}
Dot.2=Dot(%0,%1)

Element.2=Nth(%0, %1)
Element.3=Nth(Nth( %0, %1 ), %2)
Expand.1=ExpandBrackets(%0)
Evaluate.1=Eval(%0)

Factor.1=Factor(%0)
Factors.1=Factors(%0)
Floor.1=Floor(N(%0))
FPart.1=%0-Sign(%0)*Floor(Abs(%0))

GCD.2=Gcd(%0, %1)
GetDenom.1=Denominator(%0)
GetPrecision.1=BuiltinPrecisionGet(%0)
GetNum.1=Numerator(%0)

HCF.2=Gcd(%0, %1)

Im.1=Im(%0)
ImpDif.3=-(Differentiate(%1) %0)/(Differentiate(%2) %0)
# add eval for integral to allow function definitions, e.g. f(x) := Integral(x^2, x)
Integral.1=Eval(AntiDeriv(x, %0))
Integral.2=Eval(AntiDeriv(%1, %0))
Integral.4=Eval(Integrate(%1, %2, %3) %0)
Intersect.2=RemoveDuplicates(MapArgs( Solve({%0, %1}, {x, y}), {{elem}, Nth(elem,2)} ))
Invert.1=Inverse(%0)
IPart.1=Sign(%0)*Floor(Abs(%0))
IsPrime.1=IsPrime(%0)

KeepInput.1=Hold(%0)

LCM.2=Lcm(%0, %1)
Ld.1=Ln(%0)/Ln(2)
LeftSide.1=If(IsList(%0), EquationLeft(Nth(%0,1)), EquationLeft(%0))
Lg.1=Ln(%0)/Ln(10)
Limit.2=[Local(x); (Limit(x, %1) %0);]
Limit.3=[Local(%1);(Limit(%1, %2) %0);]
LimitAbove.2=[Local(x); (Limit(x, %1, Right) %0);]
LimitAbove.3=[Local(%1);(Limit(%1, %2, Right) %0);]
LimitBelow.2=[Local(x); (Limit(x, %1, Left) %0);]
LimitBelow.3=[Local(%1);(Limit(%1, %2, Left) %0);]
Ln.1=Ln(%0)
Log.1=Ln(%0)
Log.2=Ln(%1)/Ln(%0)

Max.N=Maximum({%})
Min.N=Minimum({%})
Mod.2=Modulo(%0, %1)

N.1=N(%0)
N.2=N(%0, %1)
nCr.2=BinomialCoefficient(%0,%1)
NextPrime.1=NextPrime(%0)
NormPdf.3=PDF(NormalDistribution(%0,%1),%2)
NormCdf.3=N(CDF(NormalDistribution(%0,%1),%2))
NormCdf.4=N(CDF(NormalDistribution(%0,%1),%3)-CDF(NormalDistribution(%0,%1),%2))
nPr.2=Permutations(%0,%1)
Numerator=Numer(%0)
Numeric.1=N(%0)
Numeric.2=N(%0, %1)
NRoot.2=If(Sign((-1)^%1)=1,Abs(Eval((%0)^(1/%1))),Eval((%0)^(1/%1)))
#to be replaced
NSolve.1=N(Solve(%0,x))

OrthogonalVector.1={-%0[2], %0[1]}

PartialFractions.1=Apart(%0)
PrevPrime.1=[t°e°m°p:=%0-1; While (Not IsPrime(t°e°m°p)) t°e°m°p:=t°e°m°p-1;t°e°m°p;]
PrimeFactors.1=[t°e°m°plist:={};t°e°m°pnumber:=%0 ;While (t°e°m°pnumber>1) [t°e°m°p:=2;While (Modulo(t°e°m°pnumber,t°e°m°p)>0) t°e°m°p++; DestructiveAppend(t°e°m°plist,t°e°m°p); t°e°m°pnumber:=t°e°m°pnumber/t°e°m°p;]; t°e°m°plist;]
Product.1=Product(i, 1, Length(%0), Nth(%0,i))
Product.4=Product(%1, %2, %3, %0)
Prog.1=[ %0 ;]
PropFrac.1=Sign(%0)*Floor(Abs(%0))+(%0-Sign(%0)*Floor(Abs(%0)))

Random.2=RandomInteger(%0,%1)
RandomPoly.3=RandomPoly(x,%0,%1,%2)
RandomPoly.4=RandomPoly(%0,%1,%2,%3)
Rationalize.1=Rationalize(%0)
Re.1=Re(%0)
RightSide.1=If(IsList(%0), EquationRight(Nth(%0,1)), EquationRight(%0))
Root.1=FindRealRoots(%0)
rref.1=ReducedRowEchelonForm(%0)

Seq.4=Table(%0,%1,%2,%3)
Seq.3=Table(%0,x,%1,%2)
Sequence.4=Table(%0,%1,%2,%3,1)
Sequence.3=Table(%0,x,%1,%2,1)
SetPrecision.1=BuiltinPrecisionSet(%0)
Sgn.1=Sign(%0)
Simplify.1=ExpandBrackets(Simplify(Rationalize(%0)))
# used by AlgoSimplify
SimplifyFull.1=Simplify(TrigSimpCombine(FactorCancel(%0)))
#SimplifyFull.1=Simplify(TrigSimpCombine(%0))
# Solutions gives a list like {2,4} instead of {x==2, x==4}
Solutions.1=RemoveDuplicates(MapArgs( Solve( %0, x), {{elem}, Nth(elem,2)} ))
Solutions.2=RemoveDuplicates(MapArgs( Solve( %0, %1), {{elem}, Nth(elem,2)} ))
# Solve gives a list like {x==2, x==4}
Solve.1=RemoveDuplicates(Solve(%0, x))
Solve.2=RemoveDuplicates(Solve(%0, %1))
Sqrt.1=Eval(Sqrt(%1))
#TODO: make substitute work for equation results
# substitute list of equations, e.g. Substitute[x + 5,  {x=-2, x=2}] gives {3, 7}
# doesn't work: Substitute.2=MapArgs( {x==2, x==6}, {{elem}, [Local(left, right); left := Eval(EquationLeft(elem)); right := Eval(EquationRight(elem)); (Subst(left, right) elem + 5);]} )
Substitute.3=[ Local(resultHold); ExceptionCatch(Local(%1),0); resultHold := (Subst(%1, %2) Hold(%0)); If(resultHold != Hold(%0), resultHold, (Subst(%1, %2) %0));]
#Substitute.3=Subst(%1, %2) %0
#t?e?m?p can't be used as variable name in GeoGebra but in MathPiper, so we are save
SubstituteParallel.2=[Local(result,t?e?m?p); result:=%1; ForEach(var,%0) [result:=Subst(Nth(var,1),t?e?m?p#Nth(var,1)) result;];ForEach(var,%0) [result:=Subst(t?e?m?p#Nth(var,1),Nth(var,2)) result;];result;]

Taylor.3=Taylor3(x,%1,%2)(%0) 
Taylor.4=Taylor3(%1,%2,%3)(%0) 
ToBinomial.1=Re(%0)+I*Im(%0)
ToDecimal.1=N(%0)
ToExponential.1=Abs(%0)*Exp(I*Arg(%0))
ToPolar.1=Abs(%0)*Cos(Arg(%0))+I*Abs(%0)*Sin(Arg(%0))
Transpose.1=Transpose(%0)

UnitVector.1=Normalize(%0)
UnitOrthogonalVector.1=Normalize({-%0[2], %0[1]})