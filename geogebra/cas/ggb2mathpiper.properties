####
# Command translation table from GeoGebra to MathPiper
# e.g. Expand[ 2(x+3) ] is translated to ExpandBrackets( 2*(x+3) )
###

Abs.1=Abs(%0)
Arg.1=Arg(%0)

BinomPdf.3=PMF(BinomialDistribution(%1,%0),%2)
BinomPdf.2=Table(PMF(BinomialDistribution(%1,%0),ind),ind,0,%1)
BinomCdf.3=CDF(BinomialDistribution(%1,%0),%2)
BinomCdf.2=Table(CDF(BinomialDistribution(%1,%0),ind),ind,0,%1)
NormPdf.3=PDF(NormalDistribution(%0,%1),%2)
NormCdf.3=N(CDF(NormalDistribution(%0,%1),%2))
NormCdf.4=N(CDF(NormalDistribution(%0,%1),%3)-CDF(NormalDistribution(%0,%1),%2))

Coefficients.1=Coef(%0,x,0 .. Degree(%0))
ComDenom.2=Lcm(Denominator(%0),Denominator(%1))
Complex.2=%0+%1*I
Degree.1=Degree(%0)
Delete.1=[Unbind(%0); Retract("%0", *);]
Denominator=Denominator(%0)
Derivative.1=Eval(Differentiate(x) %0)
Derivative.2=Eval(Differentiate(%1) %0)
Derivative.3=Eval(Differentiate(%1, %2) %0)
Div.2=Quotient(%0, %1)
Determinant.1=RecursiveDeterminant(%0)
Element.2=Nth(%0, %1)
Element.3=Nth(Nth( %0, %1 ), %2)
Expand.1=ExpandBrackets(%0)
Evaluate.1=Eval(%0)
Factor.1=Factor(%0)
Factors.1=Factors(%0)
Floor.1=Floor(N(%1))
FPart.1=%0-Sign(%0)*Floor(Abs(%0))
GCD.2=Gcd(%0, %1)
GetDenom.1=Denominator(%0)
GetPrecision.1=BuiltinPrecisionGet(%0)
GetNum.1=Numerator(%0)
HCF.2=Gcd(%0, %1)
# add eval for integral to allow function definitions, e.g. f(x) := Integral(x^2, x)
Integral.1=Eval(AntiDeriv(x, %0))
Integral.2=Eval(AntiDeriv(%1, %0))
Integral.4=Eval(Integrate(%1, %2, %3) %0)
Invert.1=Inverse(%0)
IPart.1=Sign(%0)*Floor(Abs(%0))
KeepInput.1=Hold(%0)
LeftSide.1=If(IsList(%0), EquationLeft(Nth(%0,1)), EquationLeft(%0))
Limit.2=Limit(x,%1)%0
Limit.3=Limit(%1, %2) %0
LimitAbove.2=(Limit(x,%1,Right)%0)
LimitAbove.3=(Limit(%1,%2,Right)%0)
LimitBelow.2=(Limit(x,%1,Left)%0)
LimitBelow.3=(Limit(%1,%2,Left)%0)
LCM.2=Lcm(%0, %1)

Ld.1=Ln(%0)/Ln(2)
Lg.1=Ln(%0)/Ln(10)
Ln.1=Ln(%0)
Log.1=Ln(%0)
Log.2=Ln(%1)/Ln(%0)

Max.N=Maximum({%})
Min.N=Minimum({%})
Mod.2=Modulo(%0, %1, {x})

nCr.2=BinomialCoefficient(%0,%1)
nPr.2=Permutations(%0,%1)
Numerator=Numer(%0)
Numeric.1=N(%0)
Numeric.2=N(%0, %1)
NRoot.2=If(Sign((-1)^%1)=1,Abs(Eval((%0)^(1/%1))),Eval((%0)^(1/%1)))
#to be replaced
NSolve.1=N(Solve(%0,x))

PartialFractions.1=Apart(%0)
Product.1=Product(i, 1, Length(%0), Nth(%0,i))
Product.4=Product(%1, %2, %3, %0)
Prog.1=[ %0 ;]
PropFrac.1=Sign(%0)*Floor(Abs(%0))+(%0-Sign(%0)*Floor(Abs(%0)))
rref.1=ReducedRowEchelonForm(%0)
RightSide.1=If(IsList(%0), EquationRight(Nth(%0,1)), EquationRight(%0))
Root.1=FindRealRoots(%0)
Seq.4=Table(%0,%1,%2,%3)
Seq.3=Table(%0,x,%1,%2)
Sequence.4=Table(%0,%1,%2,%3)
Sequence.3=Table(%0,x,%1,%2)
SetPrecision.1=BuiltinPrecisionSet(%0)
Sgn.1=Sign(%0)
Simplify.1=ExpandBrackets(Simplify(%0))
# used by AlgoSimplify
SimplifyFull.1=Simplify(TrigSimpCombine(FactorCancel(%0)))
#SimplifyFull.1=Simplify(TrigSimpCombine(%0))

# Solutions gives a list like {2,4} instead of {x==2, x==4}
Solutions.1=RemoveDuplicates(MapArgs( Solve( %0, x), {{elem}, Nth(elem,2)} ))
Solutions.2=RemoveDuplicates(MapArgs( Solve( %0, %1), {{elem}, Nth(elem,2)} ))

# Solve gives a list like {x==2, x==4}
Solve.1=RemoveDuplicates(Solve(%0, x))
Solve.2=RemoveDuplicates(Solve(%0, %1))
Sqrt.1=Eval(Sqrt(%1))
Sum.1=Sum(i, 1, Length(%0), Nth(%0,i))
Sum.4=Sum(%1, %2, %3, %0)

Transpose.1=Transpose(%0)

#TODO: make substitute work for equation results
# substitute list of equations, e.g. Substitute[x + 5,  {x=-2, x=2}] gives {3, 7}
# doesn't work: Substitute.2=MapArgs( {x==2, x==6}, {{elem}, [Local(left, right); left := Eval(EquationLeft(elem)); right := Eval(EquationRight(elem)); (Subst(left, right) elem + 5);]} )
Substitute.3=[ Local(resultHold); resultHold := (Subst(%1, %2) Hold(%0)); If(resultHold != Hold(%0), resultHold, (Subst(%1, %2) %0));]
#Substitute.3=Subst(%1, %2) %0
#t°e°m°p can't be used as variable name in GeoGebra but in MathPiper, so we are save
SubstituteParallel.2=[Local(result,t°e°m°p); result:=%1; ForEach(var,%0) [result:=Subst(Nth(var,1),t°e°m°p#Nth(var,1)) result;];ForEach(var,%0) [result:=Subst(t°e°m°p#Nth(var,1),Nth(var,2)) result;];result;]

Taylor.3=Taylor3(x,%1,%2)(%0) 
Taylor.4=Taylor3(%1,%2,%3)(%0) 

UnitVector.1=Normalize(%0)
UnitOrthogonalVector.1=Normalize({-%0[2], %0[1]})
OrthogonalVector.1={-%0[2], %0[1]}